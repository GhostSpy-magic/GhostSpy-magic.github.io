<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content="John Doe">
    <meta name="keywords" content>
    <title>Python 实用编程技巧（多进程篇） ~ Hexo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>Hexo</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">Python 实用编程技巧（多进程篇）</p>
            <br>
            
            <p>Tuesday, October 2nd 2018, 12:50 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h2 id="一、为什么选择多进程编程"><a href="#一、为什么选择多进程编程" class="headerlink" title="一、为什么选择多进程编程"></a><strong>一、为什么选择多进程编程</strong></h2><p>我们在多线程篇说过 Python 有一个 GIL 锁，这导致我们无法发挥多核CPU 的性能，于是对于一些耗CPU 的操作（比如：计算、图像处理），我们使用多线程编程显得就不那么好，于是我们采用多进程编程，这样就能充分利用CPU 并发来提高运行的效率（多I/O操作的尽量使用多线程编程，这样不会影响性能）<br><a id="more"></a></p>
<blockquote>
<p><strong>注：</strong>本文使用 Python3 实现，但是除了和 Python2 在 print 上的差别外其他都是一样的</p>
</blockquote>
<h2 id="二、多线程与多进程的直观比较"><a href="#二、多线程与多进程的直观比较" class="headerlink" title="二、多线程与多进程的直观比较"></a><strong>二、多线程与多进程的直观比较</strong></h2><h3 id="1-我们以计算斐波那契数列为例来比较两种方式的执行速度"><a href="#1-我们以计算斐波那契数列为例来比较两种方式的执行速度" class="headerlink" title="1.我们以计算斐波那契数列为例来比较两种方式的执行速度"></a><strong>1.我们以计算斐波那契数列为例来比较两种方式的执行速度</strong></h3><h4 id="1-多线程方式"><a href="#1-多线程方式" class="headerlink" title="1.多线程方式"></a><strong>1.多线程方式</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>import time
from concurrent.futures import ThreadPoolExecutor,as_completed

def fib(n):
    if n&lt;= 2:
        return 1
    return fib(n-1)+fib(n-2)


with ThreadPoolExecutor(3) as executor:
    tasks = [executor.submit(fib, (num)) for num in range(25,35)]
    start_time = time.time()
    for future in as_completed(tasks):
        data = future.result()
        print(&quot;exe result {num}&quot;.format(num = data))

    print(&quot;last time is {time}&quot;.format(time = time.time()-start_time))
</code></pre><p><strong>结果：</strong></p>
<pre><code>exe result 75025
exe result 121393
exe result 196418
exe result 317811
exe result 514229
exe result 832040
exe result 1346269
exe result 2178309
exe result 3524578
exe result 5702887
last time is 3.65224289894104
</code></pre><h4 id="2-多进程方式："><a href="#2-多进程方式：" class="headerlink" title="2.多进程方式："></a><strong>2.多进程方式：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>import time
from concurrent.futures import ThreadPoolExecutor,as_completed
from concurrent.futures import ProcessPoolExecutor

def fib(n):
    if n&lt;= 2:
        return 1
    return fib(n-1)+fib(n-2)

if __name__ == &apos;__main__&apos;:
    with ProcessPoolExecutor(3) as executor:
        tasks = [executor.submit(fib, (num)) for num in range(25,35)]
        start_time = time.time()
        for future in as_completed(tasks):
            data = future.result()
            print(&quot;exe result {num}&quot;.format(num = data))

        print(&quot;last time is {time}&quot;.format(time = time.time()-start_time))
</code></pre><p><strong>结果：</strong></p>
<pre><code>exe result 75025
exe result 121393
exe result 196418
exe result 317811
exe result 514229
exe result 832040
exe result 1346269
exe result 2178309
exe result 3524578
exe result 5702887
last time is 2.270967960357666
</code></pre><p><strong>结论：</strong></p>
<p>可以很清楚地看到使用多线程的方式计算来的更快</p>
<h3 id="2-我们以频繁I-O操作的任务为例来比较两种方式的执行速度"><a href="#2-我们以频繁I-O操作的任务为例来比较两种方式的执行速度" class="headerlink" title="2.我们以频繁I/O操作的任务为例来比较两种方式的执行速度"></a><strong>2.我们以频繁I/O操作的任务为例来比较两种方式的执行速度</strong></h3><h4 id="1-多线程方式-1"><a href="#1-多线程方式-1" class="headerlink" title="1.多线程方式"></a><strong>1.多线程方式</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>import time
from concurrent.futures import ThreadPoolExecutor,as_completed
from concurrent.futures import ProcessPoolExecutor


def random_sleep(n):
    time.sleep(n)
    return n

if __name__ == &apos;__main__&apos;:
    with ThreadPoolExecutor(3) as executor:
        tasks = [executor.submit(random_sleep, (num)) for num in [2]*30]
        start_time = time.time()
        for future in as_completed(tasks):
            data = future.result()
            print(&quot;exe result {num}&quot;.format(num = data))

        print(&quot;last time is {time}&quot;.format(time = time.time()-start_time))
</code></pre><p><strong>结果：</strong></p>
<pre><code>last time is 20.006227493286133
</code></pre><h4 id="2-多进程方式：-1"><a href="#2-多进程方式：-1" class="headerlink" title="2.多进程方式："></a><strong>2.多进程方式：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>import time
from concurrent.futures import ThreadPoolExecutor,as_completed
from concurrent.futures import ProcessPoolExecutor

def random_sleep(n):
    time.sleep(n)
    return n

if __name__ == &apos;__main__&apos;:
    with ProcessPoolExecutor(3) as executor:
        tasks = [executor.submit(random_sleep, (num)) for num in [2]*30]
        start_time = time.time()
        for future in as_completed(tasks):
            data = future.result()
            print(&quot;exe result {num}&quot;.format(num = data))

        print(&quot;last time is {time}&quot;.format(time = time.time()-start_time))
</code></pre><p><strong>结果:</strong></p>
<pre><code>last time is 20.205044746398926
</code></pre><p><strong>结论：</strong></p>
<p>对于I/O 操作来讲，多线程方式要优于多进程方式</p>
<h2 id="三、multiprocessing-多进程编程"><a href="#三、multiprocessing-多进程编程" class="headerlink" title="三、multiprocessing 多进程编程"></a><strong>三、multiprocessing 多进程编程</strong></h2><p>进程的数据是完全隔离的，不能像线程一样通过全局变量进行通信。<br>多进程编程首选还是使用上面我们测试用的那个包，因为他和多线程编程的接口一致，设计精良，而这个multiprocessig 更加底层一些</p>
<p><strong>示例代码：</strong></p>
<pre><code>import multiprocessing
import time

def get_html(n):
    time.sleep(n)
    print(&quot;sub progress success&quot;)
    return n

if __name__ == &apos;__main__&apos;:
    progress = multiprocessing.Process(target=get_html,args=(2,))
    progress.start()
    print(progress.pid)
    progress.join()
    print(&quot;main progress end&quot;)
</code></pre><p><strong>结果：</strong></p>
<pre><code>29244
sub progress success
main progress end
</code></pre><h2 id="四、使用进程池"><a href="#四、使用进程池" class="headerlink" title="四、使用进程池"></a><strong>四、使用进程池</strong></h2><p><strong>示例代码：</strong></p>
<pre><code>import multiprocessing
import time

def get_html(n):
    time.sleep(n)
    print(&quot;sub process success&quot;)
    return n

if __name__ == &apos;__main__&apos;:
    pool = multiprocessing.Pool(multiprocessing.cpu_count())# 创建线程池
    result = pool.apply_async(get_html,args=(3,)) #添加进线程池
    pool.close() #禁止其他进程再次加入
    pool.join()
    print(result.get())
</code></pre><p><strong>结果：</strong></p>
<pre><code>sub process success
3
</code></pre><p>当然我们可能会想用迭代的进程池，没问题，Python 给我们提供了这样的方法 pool.imap()，</p>
<p><strong>示例代码</strong>：</p>
<pre><code>import multiprocessing
import time

def get_html(n):
    time.sleep(n)
    print(&quot;sub process success&quot;)
    return n

if __name__ == &apos;__main__&apos;:
    pool = multiprocessing.Pool(multiprocessing.cpu_count())# 创建线程池
    for result in pool.imap(get_html,[1,3,5,7,9]):
        print(&quot;sleep {time} success&quot;.format(time = result))
</code></pre><p><strong>结果：</strong></p>
<pre><code>sub process success
sleep 1 success
sub process success
sleep 3 success
sub process success
sleep 5 success
sub process success
sleep 7 success
sub process success
sleep 9 success
</code></pre><h2 id="五、进程间通信"><a href="#五、进程间通信" class="headerlink" title="五、进程间通信"></a><strong>五、进程间通信</strong></h2><h3 id="方法一：使用进程队列"><a href="#方法一：使用进程队列" class="headerlink" title="方法一：使用进程队列"></a><strong>方法一：使用进程队列</strong></h3><p><strong>示例代码：</strong></p>
<pre><code>from multiprocessing import Process,Queue
import time

def Producer(queue):
    queue.put(&quot;a&quot;)
    time.sleep(2)

def Consumer(queue):
    time.sleep(2)
    res = queue.get()
    print(res)

if __name__ == &apos;__main__&apos;:
    queue = Queue(10)
    task1 = Process(target=Producer,args=(queue,))
    task2 = Process(target=Consumer,args=(queue,))
    task1.start()
    task2.start()
    task1.join()
    task2.join()
</code></pre><p><strong>结果：</strong></p>
<pre><code>a
</code></pre><blockquote>
<p><strong>注意：</strong></p>
<p>1.共享全局变量进行通信的方法在多进程编程中是不能实现的，因为进程在 fork 的时候会将所有的变量赋值一分到自己的空间，进程之间是隔离的</p>
<p>2.Queue() 是不能用于进程池的进程之间的通信的</p>
</blockquote>
<h3 id="方法二：使用Manager-中的-Queue-实现进程池中的通信"><a href="#方法二：使用Manager-中的-Queue-实现进程池中的通信" class="headerlink" title="方法二：使用Manager 中的 Queue 实现进程池中的通信"></a><strong>方法二：使用Manager 中的 Queue 实现进程池中的通信</strong></h3><p><strong>示例代码：</strong></p>
<pre><code>from multiprocessing import Process,Queue,Pool,Manager
import time

def Producer(queue):
    queue.put(&quot;a&quot;)
    time.sleep(2)

def Consumer(queue):
    time.sleep(2)
    res = queue.get()
    print(res)

if __name__ == &apos;__main__&apos;:
    queue = Manager().Queue(10)
    pool = Pool(2)
    pool.apply_async(Producer,args=(queue,))
    pool.apply_async(Consumer,args=(queue,))
    pool.close()
    pool.join()
</code></pre><p><strong>结果：</strong></p>
<pre><code>a
</code></pre><h3 id="方法三：使用Pipe-实现两个进程之间的通信"><a href="#方法三：使用Pipe-实现两个进程之间的通信" class="headerlink" title="方法三：使用Pipe 实现两个进程之间的通信"></a><strong>方法三：使用Pipe 实现两个进程之间的通信</strong></h3><p>pipe 只能用于两个进程之间的通信，效率比queue 高</p>
<p><strong>示例代码：</strong></p>
<p>from multiprocessing import Process,Pipe</p>
<p>def Producer(pipe):<br>    pipe.send(“a”)</p>
<p>def Consumer(pipe):<br>    print(pipe.recv())</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    receive_pipe,send_pipe = Pipe()<br>    task1 = Process(target=Producer,args=(send_pipe,))<br>    task2 = Process(target=Consumer,args=(receive_pipe,))<br>    task1.start()<br>    task2.start()<br>    task1.join()<br>    task2.join()</p>
<p><strong>结果:</strong></p>
<pre><code>a
</code></pre><h2 id="六、进程间内存共享"><a href="#六、进程间内存共享" class="headerlink" title="六、进程间内存共享"></a><strong>六、进程间内存共享</strong></h2><p><strong>示例代码：</strong></p>
<pre><code>from multiprocessing import Process
import multiprocessing

def add_data(p_dict,key,value):
    p_dict[key] = value

if __name__ == &apos;__main__&apos;:
    mgr = multiprocessing.Manager()
    progress_dict = mgr.dict()
    first_progress = Process(target=add_data,args=(progress_dict,&quot;Bob&quot;,22))
    second_progress =  Process(target=add_data,args=(progress_dict,&quot;Alic&quot;,20))
    first_progress.start()
    second_progress.start()
    first_progress.join()
    second_progress.join()
    print progress_dict
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;Bob&apos;: 22, &apos;Alic&apos;: 20}
</code></pre><p><strong>解释：</strong></p>
<p>可以看到，虽然是不同的进程，但是他们共同操纵了一个变量</p>

                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;编程 Python 进阶 备忘</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
                    <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>