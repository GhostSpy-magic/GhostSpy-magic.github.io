<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>C++ 的 Eigen 类库学习 | K0rz3n's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C++ 的 Eigen 类库学习</h1><a id="logo" href="/.">K0rz3n's Blog</a><p class="description">Shell-is-Only-the-Beginning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Inicio</i></a><a href="/archives/"><i class="fa fa-archive"> Archivo</i></a><a href="/about/"><i class="fa fa-user"> Acerca de</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++ 的 Eigen 类库学习</h1><div class="post-meta">Oct 12, 2018<span> | </span><span class="category"><a href="/categories/编程/">编程</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contenidos</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Eigen-是什么"><span class="toc-number">1.</span> <span class="toc-text">一、Eigen 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、如何配置"><span class="toc-number">2.</span> <span class="toc-text">二、如何配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Eigen-基础"><span class="toc-number">3.</span> <span class="toc-text">三、Eigen 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Matrix-类"><span class="toc-number">3.1.</span> <span class="toc-text">1.Matrix 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-基本："><span class="toc-number">3.1.1.</span> <span class="toc-text">1.基本：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-向量"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-动态值"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.动态值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-构造函数"><span class="toc-number">3.1.4.</span> <span class="toc-text">4.构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-系数访问器"><span class="toc-number">3.1.5.</span> <span class="toc-text">5.系数访问器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-逗号初始化"><span class="toc-number">3.1.6.</span> <span class="toc-text">6.逗号初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-调整"><span class="toc-number">3.1.7.</span> <span class="toc-text">7.调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-分配和调整大小"><span class="toc-number">3.1.8.</span> <span class="toc-text">8.分配和调整大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、矩阵和向量算数"><span class="toc-number">4.</span> <span class="toc-text">四、矩阵和向量算数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-加减"><span class="toc-number">4.1.</span> <span class="toc-text">1.加减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-标量的乘除"><span class="toc-number">4.2.</span> <span class="toc-text">2.标量的乘除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-转置、共轭、伴随"><span class="toc-number">4.3.</span> <span class="toc-text">3.转置、共轭、伴随</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-矩阵-矩阵和矩阵-向量乘法"><span class="toc-number">4.4.</span> <span class="toc-text">4.矩阵 - 矩阵和矩阵 - 向量乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、高级初始化"><span class="toc-number">5.</span> <span class="toc-text">五、高级初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-将矩阵进行拼接"><span class="toc-number">5.1.</span> <span class="toc-text">1.将矩阵进行拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-特殊矩阵"><span class="toc-number">5.2.</span> <span class="toc-text">2.特殊矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-用作临时对象"><span class="toc-number">5.3.</span> <span class="toc-text">3.用作临时对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、数组"><span class="toc-number">6.</span> <span class="toc-text">六、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概念："><span class="toc-number">6.1.</span> <span class="toc-text">1.概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-访问Array中的值"><span class="toc-number">6.2.</span> <span class="toc-text">2.访问Array中的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-加减"><span class="toc-number">6.3.</span> <span class="toc-text">3.加减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-数组乘法"><span class="toc-number">6.4.</span> <span class="toc-text">4.数组乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-其他系数运算"><span class="toc-number">6.5.</span> <span class="toc-text">5.其他系数运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、在数组和矩阵表达式之间转换"><span class="toc-number">7.</span> <span class="toc-text">七、在数组和矩阵表达式之间转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、实例应用"><span class="toc-number">8.</span> <span class="toc-text">八、实例应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-求矩阵的行列式"><span class="toc-number">8.1.</span> <span class="toc-text">1. 求矩阵的行列式</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="一、Eigen-是什么"><a href="#一、Eigen-是什么" class="headerlink" title="一、Eigen 是什么"></a><strong>一、Eigen 是什么</strong></h2><p>Eigen 是一个 C++ 中的用于科学计算（矩阵）的类库，提供了非常方便的接口，最近我们小组需要做一个项目，里面涉及到很多的矩阵的计算，于是我打算使用这个类库结合我的 CLion 写代码</p>
<h2 id="二、如何配置"><a href="#二、如何配置" class="headerlink" title="二、如何配置"></a><strong>二、如何配置</strong></h2><p>下载最新的 release 安装包 解压到项目的目录下（当然任何目录都可以，我习惯上解压到项目的目录下，这样比较方便管理），然后我们配置我们的 CMakeLists.txt</p>
<a id="more"></a>
<p><strong>CMakeLists.txt</strong></p>
<pre><code>cmake_minimum_required(VERSION 3.10)
project(juzhen)

set(CMAKE_CXX_STANDARD 11)


include_directories(../eigen)//这里写你的解压目录


add_executable(juzhen main.cpp)
</code></pre><p><strong>main.cpp</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {
    typedef Matrix&lt;int,3,3&gt; hh;
    MatrixXd m = MatrixXd::Random(3,3);
    //m = (m + MatrixXd::Constant(3,3,1.2)) * 50;
    MatrixXd c = MatrixXd::Constant(3,3,1)*10;
    hh x;
    cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
    cout &lt;&lt; &quot;c =&quot; &lt;&lt; endl &lt;&lt; c &lt;&lt; endl;
    cout &lt;&lt; &quot;x =&quot; &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;
}
</code></pre><p>这样就能运行啦</p>
<h2 id="三、Eigen-基础"><a href="#三、Eigen-基础" class="headerlink" title="三、Eigen 基础"></a><strong>三、Eigen 基础</strong></h2><h3 id="1-Matrix-类"><a href="#1-Matrix-类" class="headerlink" title="1.Matrix 类"></a><strong>1.Matrix 类</strong></h3><h4 id="1-基本："><a href="#1-基本：" class="headerlink" title="1.基本："></a><strong>1.基本：</strong></h4><p>在Eigen中，所有矩阵和向量都是Matrix模板类的对象。向量只是矩阵的一种特殊情况，有1行或1列。</p>
<p><strong>Matrix的三个必需模板参数是：</strong></p>
<pre><code>Matrix &lt;typename Scalar，int RowsAtCompileTime，int ColsAtCompileTime&gt;
</code></pre><p><strong>例如：</strong> Matrix4f是浮动的4x4矩阵</p>
<pre><code>typedef Matrix &lt;float，4,4&gt; Matrix4f ;
</code></pre><p>假如：我想生成一个 int 型的 3x3 的矩阵</p>
<p><strong>示例代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {
    typedef Matrix&lt;int,3,3&gt; hh;
    hh x;
    cout &lt;&lt; &quot;x =&quot; &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>x =
2001839094         36          0
2001791111    6880932 1275664310
        -1          4    6880948
</code></pre><h4 id="2-向量"><a href="#2-向量" class="headerlink" title="2.向量"></a><strong>2.向量</strong></h4><p>向量只是一种特殊的矩阵而已</p>
<p><strong>列向量：</strong></p>
<pre><code>typedef Matrix &lt;float，3,1&gt; Vector3f ;
</code></pre><p><strong>行向量：</strong></p>
<pre><code>typedef Matrix &lt;int，1,2&gt; RowVector2i ;
</code></pre><h4 id="3-动态值"><a href="#3-动态值" class="headerlink" title="3.动态值"></a><strong>3.动态值</strong></h4><p>我们当然不满足在编译时就确定矩阵的大小，于是他给我们也提供了对应的方法</p>
<p>例如，便捷typedef MatrixXd，即具有动态大小的双精度矩阵，定义如下：</p>
<pre><code>typedef Matrix &lt;double，Dynamic，Dynamic&gt; MatrixXd ;
</code></pre><p>同样，我们定义了一个不言自明的typedef VectorXi如下：</p>
<pre><code>typedef Matrix &lt;int，Dynamic，1&gt; VectorXi ;
</code></pre><p>您可以完美地拥有例如具有动态列数的固定行数，如下所示：</p>
<pre><code>Matrix &lt;float，3，Dynamic&gt;
</code></pre><h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a><strong>4.构造函数</strong></h4><p>默认构造函数始终可用，从不执行任何动态内存分配，也从不初始化矩阵系数。你可以做：</p>
<pre><code>Matrix3f a;
MatrixXf b;
</code></pre><p>a 是一个3乘3的矩阵，具有未初始化系数的普通浮点数<br>b 是一个动态大小的矩阵，其大小目前是0乘0，并且其系数数组尚未分配。</p>
<p><strong>注意：</strong></p>
<pre><code>Matrix3i d;
</code></pre><p>这里代表声明了一个 Int 型的 3x3 的矩阵，也就是说 最后的f 代表的是 float </p>
<p>对于矩阵，始终首先传递行数。对于矢量，只需传递矢量大小。它们使用给定的大小分配系数数组，但不自行初始化系数：</p>
<pre><code>MatrixXf a（10,15）;
VectorXf b（30）;
</code></pre><p>a 是一个10x15动态大小的矩阵，具有已分配但当前未初始化的系数。<br>b 是一个大小为30的动态大小向量，具有已分配但当前未初始化的系数</p>
<p><strong>注意：</strong></p>
<pre><code>RowVector2d e(1.0,2.0);
</code></pre><p>这个代表生成的是一个行向量（不加 row 是列向量）</p>
<h4 id="5-系数访问器"><a href="#5-系数访问器" class="headerlink" title="5.系数访问器"></a><strong>5.系数访问器</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main()
{
    MatrixXd m(2,2);
    m(0,0)= 3;
    m(1,0)= 2.5;
    m(0,1)= -1;
    m(1,1)= m(1,0)+ m(0,1);
    std :: cout &lt;&lt; &quot;这是矩阵m：\n&quot; &lt;&lt; m &lt;&lt; std :: endl;

    VectorXd v(2);
    v(0)= 4;
    v(1)= v(0) - 1;
    std :: cout &lt;&lt; &quot;这是向量v:\n&quot; &lt;&lt; v &lt;&lt; std :: endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>这是矩阵m：
  3  -1
2.5 1.5
这是向量v:
4
3
</code></pre><h4 id="6-逗号初始化"><a href="#6-逗号初始化" class="headerlink" title="6.逗号初始化"></a><strong>6.逗号初始化</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>int main()
{
    Matrix3f m;
    m &lt;&lt; 1,2,3,
        4,5,6,
        7,8,9;
    std :: cout &lt;&lt; m &lt;&lt;endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>1 2 3
4 5 6
7 8 9
</code></pre><h4 id="7-调整"><a href="#7-调整" class="headerlink" title="7.调整"></a><strong>7.调整</strong></h4><p>可以通过rows（），cols（）和size（）检索矩阵的当前大小。这些方法分别返回行数，列数和系数数。调整动态大小矩阵的大小由resize（）方法完成。</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    MatrixXd m(2,5);
    m.resize(4,3);
    std :: cout &lt;&lt; &quot;矩阵m的大小&quot; &lt;&lt; m.rows() &lt;&lt; &quot;x&quot; &lt;&lt; m.cols()&lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;它有&quot; &lt;&lt; m.size()&lt;&lt; &quot;系数&quot; &lt;&lt; std :: endl;


    VectorXd v(2);
    v.resize(5);
    std :: cout &lt;&lt; &quot;向量v的大小为&quot; &lt;&lt; v.size()&lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;作为矩阵,v的大小&quot; &lt;&lt; v.rows()&lt;&lt; &quot;x&quot; &lt;&lt; v.cols()&lt;&lt; std :: endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>矩阵m的大小4x3
它有12系数
向量v的大小为5
作为矩阵,v的大小5x1
</code></pre><h4 id="8-分配和调整大小"><a href="#8-分配和调整大小" class="headerlink" title="8.分配和调整大小"></a><strong>8.分配和调整大小</strong></h4><p>这里实际上是个C++ 中等号的重载</p>
<p>Eigen自动调整左侧的矩阵大小，使其与右侧大小的矩阵大小相匹配。例如：</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    MatrixXf a(2,2);
    std :: cout &lt;&lt; &quot;a is size &quot; &lt;&lt; a.rows() &lt;&lt; &quot;x&quot; &lt;&lt; a.cols()&lt;&lt; std :: endl;
    MatrixXf b(3,3);
    a = b;
    std :: cout &lt;&lt; &quot;a现在大小&quot; &lt;&lt; a.rows()&lt;&lt; &quot;x&quot; &lt;&lt; a.cols()&lt;&lt; std :: endl;
}
</code></pre><p><strong>结果:</strong></p>
<pre><code>a is size 2x2
a现在大小3x3
</code></pre><h2 id="四、矩阵和向量算数"><a href="#四、矩阵和向量算数" class="headerlink" title="四、矩阵和向量算数"></a><strong>四、矩阵和向量算数</strong></h2><h3 id="1-加减"><a href="#1-加减" class="headerlink" title="1.加减"></a><strong>1.加减</strong></h3><p>二元运算符+如 a+b<br>二元运算符 - 如 a-b<br>一元算子 - 如同 -a<br>复合运算符+ =如 a+=b<br>复合运算符 - =如 a-=b</p>
<p><strong>注意：</strong></p>
<p>运算符的左值和右值，必须要有相同的类型和相同数量的行列</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    Matrix2d a;
    a &lt;&lt; 1,2,
    3,4;
    MatrixXd b(2,2);
    b &lt;&lt; 2,3,
    1,4;
    std :: cout &lt;&lt; &quot;a + b = \n&quot; &lt;&lt; a + b &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;a  -  b = \n&quot; &lt;&lt; a  -  b &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;做一个+ = b;&quot; &lt;&lt; std :: endl;
    a += b;
    std :: cout &lt;&lt; &quot;现在 a = \n&quot; &lt;&lt; a &lt;&lt; std :: endl;
    Vector3d v(1,2,3);
    Vector3d w(1,0,0);
    std :: cout &lt;&lt; &quot;-v + w - v = \n&quot; &lt;&lt;  -v + w - v &lt;&lt; std :: endl;
}
</code></pre><h3 id="2-标量的乘除"><a href="#2-标量的乘除" class="headerlink" title="2.标量的乘除"></a><strong>2.标量的乘除</strong></h3><p>二元运算符<em>如 matrix</em>scalar<br>二元运算符<em>如 scalar</em>matrix<br>二元运算符/如 matrix/scalar<br>复合运算符<em> =如 matrix</em>=scalar<br>复合运算符/ =如 matrix/=scalar</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    Matrix2d a;
    a &lt;&lt; 1,2,
    3,4;
    Vector3d v(1,2,3);
    std :: cout &lt;&lt; &quot;a * 2.5 = \n&quot; &lt;&lt; a * 2.5 &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;0.1 * v = \n&quot; &lt;&lt; 0.1 * v &lt;&lt; std :: endl;
    std :: cout &lt;&lt; &quot;做v *= 2;&quot; &lt;&lt; std :: endl;
    v *= 2;
    std :: cout &lt;&lt; &quot;现在v = \n&quot; &lt;&lt; v &lt;&lt; std :: endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>a * 2.5 =
2.5   5
7.5  10
0.1 * v =
0.1
0.2
0.3
做v *= 2;
现在v =
2
4
6
</code></pre><h3 id="3-转置、共轭、伴随"><a href="#3-转置、共轭、伴随" class="headerlink" title="3.转置、共轭、伴随"></a><strong>3.转置、共轭、伴随</strong></h3><p>通过成员函数transpose（），conjugate（）和adjoint（）分别获得矩阵或向量的转置$ a ^ T $，共轭$ \ bar {a} $和伴随（即，共轭转置）。$ a ^ * $$ a $</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    MatrixXf a = MatrixXf :: Random(2,2);
    cout &lt;&lt; &quot;这是矩阵a \n&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;这是矩阵a 的转置\n&quot; &lt;&lt; a.transpose()&lt;&lt; endl;
    cout &lt;&lt; &quot;这是矩阵a 的共轭\n&quot; &lt;&lt; a.conjugate()&lt;&lt;endl;
    cout &lt;&lt; &quot;这是矩阵a 的伴随\n&quot; &lt;&lt; a.adjoint()&lt;&lt; endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>这是矩阵a
-0.997497 -0.613392
 0.127171  0.617481
这是矩阵a 的转置
-0.997497  0.127171
-0.613392  0.617481
这是矩阵a 的共轭
-0.997497 -0.613392
 0.127171  0.617481
这是矩阵a 的伴随
-0.997497  0.127171
-0.613392  0.617481
</code></pre><h3 id="4-矩阵-矩阵和矩阵-向量乘法"><a href="#4-矩阵-矩阵和矩阵-向量乘法" class="headerlink" title="4.矩阵 - 矩阵和矩阵 - 向量乘法"></a><strong>4.矩阵 - 矩阵和矩阵 - 向量乘法</strong></h3><p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    Matrix2d mat;
    mat &lt;&lt; 1, 2,
            3, 4;
    Vector2d u(-1,1), v(2,0);
    std::cout &lt;&lt; &quot;Here is mat*mat:\n&quot; &lt;&lt; mat * mat &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is mat*u:\n&quot; &lt;&lt; mat*u &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is u^T*mat:\n&quot; &lt;&lt; u.transpose()*mat &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is u^T*v:\n&quot; &lt;&lt; u.transpose()*v &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Here is u*v^T:\n&quot; &lt;&lt; u*v.transpose() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Let&apos;s multiply mat by itself&quot; &lt;&lt; std::endl;
    mat = mat*mat;
    std::cout &lt;&lt; &quot;Now mat is mat:\n&quot; &lt;&lt; mat &lt;&lt; std::endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>Here is mat*mat:
 7 10
15 22
Here is mat*u:
1
1
Here is u^T*mat:
2 2
Here is u^T*v:
-2
Here is u*v^T:
-2 -0
 2  0
Let&apos;s multiply mat by itself
Now mat is mat:
 7 10
15 22
</code></pre><h2 id="五、高级初始化"><a href="#五、高级初始化" class="headerlink" title="五、高级初始化"></a><strong>五、高级初始化</strong></h2><h3 id="1-将矩阵进行拼接"><a href="#1-将矩阵进行拼接" class="headerlink" title="1.将矩阵进行拼接"></a><strong>1.将矩阵进行拼接</strong></h3><p>请记住，必须先设置大小，然后才能使用逗号初始值设定项</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    RowVectorXd vec1(3);
    vec1 &lt;&lt; 1, 2, 3;
    std::cout &lt;&lt; &quot;vec1 = &quot; &lt;&lt; vec1 &lt;&lt; std::endl;
    RowVectorXd vec2(4);
    vec2 &lt;&lt; 1, 4, 9, 16;
    std::cout &lt;&lt; &quot;vec2 = &quot; &lt;&lt; vec2 &lt;&lt; std::endl;
    RowVectorXd joined(7);
    joined &lt;&lt; vec1, vec2;
    std::cout &lt;&lt; &quot;joined = &quot; &lt;&lt; joined &lt;&lt; std::endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>vec1 = 1 2 3
vec2 =  1  4  9 16
joined =  1  2  3  1  4  9 16
</code></pre><p><strong>我们可以使用相同的技术来初始化具有块结构的矩阵。</strong></p>
<p><strong>实例代码：</strong></p>
<pre><code>int main()
{

    MatrixXf matA(2, 2);
    matA &lt;&lt; 1, 2, 3, 4;
    MatrixXf matB(4, 4);
    matB &lt;&lt; matA, matA/10, matA/10, matA;
    std::cout &lt;&lt; matB &lt;&lt; std::endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>  1   2 0.1 0.2
  3   4 0.3 0.4
0.1 0.2   1   2
0.3 0.4   3   4
</code></pre><p>更高级的填充：</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    Matrix3f m;
    m.row(0) &lt;&lt; 1, 2, 3;
    m.block(1,0,2,2) &lt;&lt; 4, 5, 7, 8;
    m.col(2).tail(2) &lt;&lt; 6, 9;
    std::cout &lt;&lt; m;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>1 2 3
4 5 6
7 8 9
</code></pre><h3 id="2-特殊矩阵"><a href="#2-特殊矩阵" class="headerlink" title="2.特殊矩阵"></a><strong>2.特殊矩阵</strong></h3><p>矩阵和数组都有特殊方法 Zero()</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{
    std::cout &lt;&lt; &quot;A fixed-size array:\n&quot;;
    Array33f a1 = Array33f::Zero();
    std::cout &lt;&lt; a1 &lt;&lt; &quot;\n\n&quot;;
    std::cout &lt;&lt; &quot;A one-dimensional dynamic-size array:\n&quot;;
    ArrayXf a2 = ArrayXf::Zero(3);
    std::cout &lt;&lt; a2 &lt;&lt; &quot;\n\n&quot;;
    std::cout &lt;&lt; &quot;A two-dimensional dynamic-size array:\n&quot;;
    ArrayXXf a3 = ArrayXXf::Zero(3, 4);
    std::cout &lt;&lt; a3 &lt;&lt; &quot;\n&quot;;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>A fixed-size array:
0 0 0
0 0 0
0 0 0

A one-dimensional dynamic-size array:
0
0
0

A two-dimensional dynamic-size array:
0 0 0 0
0 0 0 0
0 0 0 0
</code></pre><p><strong>类似地:</strong></p>
<p>1.静态方法Constant（value）将所有系数设置为value。如果需要指定对象的大小，则附加参数将在value参数之前，如MatrixXd::Constant(rows, cols, value)。</p>
<p>2.方法Random（）用随机系数填充矩阵或数组。</p>
<p>3.可以通过调用Identity（）获得单位矩阵; 此方法仅适用于Matrix，而不适用于Array，因为“单位矩阵”是线性代数概念。</p>
<p>4.LinSpaced方法（大小，低，高）仅适用于向量和一维数组;</p>
<p>它产生一个指定大小的向量，其系数在low和之间等间隔high。</p>
<p><strong>Eigen定义了实用函数</strong></p>
<p>如setZero（），MatrixBase :: setIdentity（）和DenseBase :: setLinSpaced（），可以方便地执行此操作。以下示例对比了构造矩阵的三种方法</p>
<p>使用静态方法和赋值，使用静态方法和逗号初始化程序，或使用setXxx（）方法。</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    const int size = 6;
    MatrixXd mat1(size, size);
    mat1.topLeftCorner(size/2, size/2)     = MatrixXd::Zero(size/2, size/2);
    mat1.topRightCorner(size/2, size/2)    = MatrixXd::Identity(size/2, size/2);
    mat1.bottomLeftCorner(size/2, size/2)  = MatrixXd::Identity(size/2, size/2);
    mat1.bottomRightCorner(size/2, size/2) = MatrixXd::Zero(size/2, size/2);
    std::cout &lt;&lt; mat1 &lt;&lt; std::endl &lt;&lt; std::endl;


    MatrixXd mat2(size, size);
    mat2.topLeftCorner(size/2, size/2).setZero();
    mat2.topRightCorner(size/2, size/2).setIdentity();
    mat2.bottomLeftCorner(size/2, size/2).setIdentity();
    mat2.bottomRightCorner(size/2, size/2).setZero();
    std::cout &lt;&lt; mat2 &lt;&lt; std::endl &lt;&lt; std::endl;


    MatrixXd mat3(size, size);
    mat3 &lt;&lt; MatrixXd::Zero(size/2, size/2), MatrixXd::Identity(size/2, size/2),
            MatrixXd::Identity(size/2, size/2), MatrixXd::Zero(size/2, size/2);
    std::cout &lt;&lt; mat3 &lt;&lt; std::endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0

0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0

0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0
</code></pre><h3 id="3-用作临时对象"><a href="#3-用作临时对象" class="headerlink" title="3.用作临时对象"></a><strong>3.用作临时对象</strong></h3><p>静态方法如Zero（）和Constant（）可用于在声明时或在赋值运算符的右侧初始化变量。您可以将这些方法视为返回矩阵或数组; 实际上，它们<strong>返回所谓的表达式对象</strong>，在需要时可以计算矩阵或数组。</p>
<p><strong>示例代码：</strong></p>
<pre><code>int main()
{

    MatrixXd m = MatrixXd::Random(3,3);
    m = (m + MatrixXd::Constant(3,3,1.2)) * 50;
    cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
    VectorXd v(3);
    v &lt;&lt; 1, 2, 3;
    cout &lt;&lt; &quot;m * v =&quot; &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>m =
10.1251 90.8741 45.0291
66.3585 68.5009 99.5962
29.3304 57.9873  92.284
m * v =
326.961
502.149
422.157
</code></pre><h2 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a><strong>六、数组</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>Array是一个类模板，采用与Matrix相同的模板参数</p>
<pre><code>Array &lt;typename Scalar，int RowsAtCompileTime，int ColsAtCompileTime&gt;
</code></pre><p>我们采用的形式是ArrayNt形式的typedef代表一维数组，其中N和t是大小和标量类型。对于二维数组，我们使用ArrayNNt形式的typedef。</p>
<p><strong>下表显示了一些示例：</strong></p>
<pre><code>Array&lt;float,Dynamic,1&gt;                            ArrayXf 
Array&lt;float,3,1&gt;                                  Array3f 
Array&lt;double,Dynamic,Dynamic&gt;                     ArrayXXd 
Array&lt;double,3,3&gt;                                 Array33d 
</code></pre><h3 id="2-访问Array中的值"><a href="#2-访问Array中的值" class="headerlink" title="2.访问Array中的值"></a><strong>2.访问Array中的值</strong></h3><p>括号运算符被重载以提供对数组系数的写和读访问，就像使用矩阵一样。此外，&lt;&lt;操作符可用于初始化数组（通过逗号初始化程序）或打印它们。</p>
<p><strong>示例代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {

    ArrayXXf  m(2,2);

    // assign some values coefficient by coefficient
    m(0,0) = 1.0; m(0,1) = 2.0;
    m(1,0) = 3.0; m(1,1) = m(0,1) + m(1,0);

    // print values to standard output
    cout &lt;&lt; m &lt;&lt; endl &lt;&lt; endl;

    // using the comma-initializer is also allowed
    m &lt;&lt; 1.0,2.0,
            3.0,4.0;

    // print values to standard output
    cout &lt;&lt; m &lt;&lt; endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>1 2
3 5

1 2
3 4
</code></pre><h3 id="3-加减"><a href="#3-加减" class="headerlink" title="3.加减"></a><strong>3.加减</strong></h3><p>添加和减去两个数组与矩阵相同。如果两个阵列具有相同的大小，则该操作有效，并且以系数方式进行加法或减法。</p>
<p>数组还支持表单的表达式，该表达式为数组中的array + scalar每个系数添加标量。这提供了一种不能直接用于Matrix对象的功能。</p>
<p><strong>示例代码：</strong></p>
<pre><code>#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;
using namespace Eigen;
using namespace std;
int main()
{
  ArrayXXf a(3,3);
  ArrayXXf b(3,3);
  a &lt;&lt; 1,2,3,
       4,5,6,
       7,8,9;
  b &lt;&lt; 1,2,3,
       1,2,3,
       1,2,3;

  // Adding two arrays
  cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; endl &lt;&lt; a + b &lt;&lt; endl &lt;&lt; endl;
  // Subtracting a scalar from an array
  cout &lt;&lt; &quot;a - 2 = &quot; &lt;&lt; endl &lt;&lt; a - 2 &lt;&lt; endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>a + b =
 2  4  6
 5  7  9
 8 10 12

a - 2 =
-1  0  1
 2  3  4
 5  6  7
</code></pre><h3 id="4-数组乘法"><a href="#4-数组乘法" class="headerlink" title="4.数组乘法"></a><strong>4.数组乘法</strong></h3><p>首先，当然你可以用一个标量乘以一个数组，这与矩阵的工作方式相同。数组与矩阵根本不同的是，当你将两个数组相乘时。矩阵将乘法解释为矩阵乘积，并且数组将乘法解释为系数乘积。因此，当且仅当它们具有相同的尺寸时，两个阵列可以相乘。</p>
<p><strong>示例代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {

    ArrayXXf a(2,2);
    ArrayXXf b(2,2);
    a &lt;&lt; 1,2,
            3,4;
    b &lt;&lt; 5,6,
            7,8;
    cout &lt;&lt; &quot;a * b = &quot; &lt;&lt; endl &lt;&lt; a * b &lt;&lt; endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>a * b =
 5 12
21 32
</code></pre><h3 id="5-其他系数运算"><a href="#5-其他系数运算" class="headerlink" title="5.其他系数运算"></a><strong>5.其他系数运算</strong></h3><p>例如，.abs（）方法取每个系数的绝对值，而.sqrt（）计算系数的平方根。如果你有两个相同大小的数组，你可以调用.min（.）来构造数组，其系数是两个给定数组的相应系数的最小值。以下示例说明了这些操作。</p>
<p><strong>示例代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {

    ArrayXf a = ArrayXf::Random(5);
    a *= 2;
    cout &lt;&lt; &quot;a =&quot; &lt;&lt; endl
         &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;a.abs() =&quot; &lt;&lt; endl
         &lt;&lt; a.abs() &lt;&lt; endl;
    cout &lt;&lt; &quot;a.abs().sqrt() =&quot; &lt;&lt; endl
         &lt;&lt; a.abs().sqrt() &lt;&lt; endl;
    cout &lt;&lt; &quot;a.min(a.abs().sqrt()) =&quot; &lt;&lt; endl
         &lt;&lt; a.min(a.abs().sqrt()) &lt;&lt; endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>a =
-1.99499
0.254341
-1.22678
 1.23496
0.340037
a.abs() =
 1.99499
0.254341
 1.22678
 1.23496
0.340037
a.abs().sqrt() =
 1.41244
0.504323
  1.1076
 1.11129
0.583127
a.min(a.abs().sqrt()) =
-1.99499
0.254341
-1.22678
 1.11129
0.340037
</code></pre><h2 id="七、在数组和矩阵表达式之间转换"><a href="#七、在数组和矩阵表达式之间转换" class="headerlink" title="七、在数组和矩阵表达式之间转换"></a><strong>七、在数组和矩阵表达式之间转换</strong></h2><p>什么时候应该使用Matrix类的对象？何时应该使用Array类的对象？您不能对数组应用Matrix运算，也不能对矩阵应用Array运算。因此，如果你需要进行矩阵乘法等线性代数运算，那么你应该使用矩阵; 如果你需要进行系数运算，那么你应该使用数组。但是，有时它并不那么简单，但您需要同时使用Matrix和Array操作。在这种情况下，您需要将矩阵转换为数组或反向转换。无论选择将对象声明为数组还是矩阵，都可以访问所有操作。</p>
<p>矩阵表达式有一个<strong>.array（）方法</strong>，可以将它们“转换”为数组表达式，因此可以轻松应用系数方法。相反，数组表达式具有<strong>.matrix（）方法</strong>。与所有Eigen表达式抽象一样，这没有任何运行时成本（假设您让编译器进行优化）。即.array（）和.matrix（）可被用作右值和作为左值。</p>
<p>Eigen禁止在表达式中混合矩阵和数组。例如，您无法直接添加矩阵和数组; 该规则的例外是赋值运算符：允许将矩阵表达式赋给数组变量，或者将数组表达式赋给矩阵变量。</p>
<p><strong>以下示例说明如何通过使用.array（）方法对Matrix对象使用数组操作</strong></p>
<p><strong>示例代码1：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {

    MatrixXf m(2,2);
    MatrixXf n(2,2);
    MatrixXf result(2,2);
    m &lt;&lt; 1,2,
            3,4;
    n &lt;&lt; 5,6,
            7,8;
    result = m * n;
    cout &lt;&lt; &quot;-- Matrix m*n: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = m.array() * n.array();
    cout &lt;&lt; &quot;-- Array m*n: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = m.cwiseProduct(n);
    cout &lt;&lt; &quot;-- With cwiseProduct: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = m.array() + 4;
    cout &lt;&lt; &quot;-- Array m + 4: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
}
</code></pre><p><strong>结果：</strong></p>
<pre><code>-- Matrix m*n: --
19 22
43 50

-- Array m*n: --
 5 12
21 32

-- With cwiseProduct: --
 5 12
21 32

-- Array m + 4: --
5 6
7 8
</code></pre><p>类似地，如果array1和array2是数组，那么表达式array1.matrix() * array2.matrix()计算它们的矩阵乘积。</p>
<p><strong>示例代码2：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;

using namespace Eigen;
using namespace std;

int main() {

    MatrixXf m(2,2);
    MatrixXf n(2,2);
    MatrixXf result(2,2);
    m &lt;&lt; 1,2,
            3,4;
    n &lt;&lt; 5,6,
            7,8;

    result = (m.array() + 4).matrix() * m;
    cout &lt;&lt; &quot;-- Combination 1: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;
    result = (m.array() * n.array()).matrix() * m;
    cout &lt;&lt; &quot;-- Combination 2: --&quot; &lt;&lt; endl &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;

}
</code></pre><p><strong>结果：</strong></p>
<pre><code>-- Combination 1: --
23 34
31 46

-- Combination 2: --
 41  58
117 170
</code></pre><p>求矩阵的行列式</p>
<h2 id="八、实例应用"><a href="#八、实例应用" class="headerlink" title="八、实例应用"></a><strong>八、实例应用</strong></h2><h3 id="1-求矩阵的行列式"><a href="#1-求矩阵的行列式" class="headerlink" title="1. 求矩阵的行列式"></a><strong>1. 求矩阵的行列式</strong></h3><pre><code>m.determinant()
</code></pre><p><strong>注意:</strong>矩阵m要是double 类型，要不然报错</p>
<p>下面是我写的一个生成 32x32 位 01 可逆矩阵的类，这里面我在生成32位矩阵的时候使用的是矩阵的拼接技术，但是这样就会出现大量的数组，并且不能用循环实现，很尴尬。</p>
<p><strong>示例代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;Eigen/Dense&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;

using namespace Eigen;
using namespace std;
typedef Matrix &lt;double,32,32&gt; Matrix32d;


class cM32{

public:

    Matrix32d create(){//返回一个可逆的32x32 随机 01 矩阵

        Matrix32d m = createPT32();
        if(check(m)) {
            cout &lt;&lt; &quot;可逆 &quot; &lt;&lt; &quot;行列式为： &quot; &lt;&lt; m.determinant() &lt;&lt; endl;
            return m;
        }else{
            cout &lt;&lt; &quot;不可逆&quot; &lt;&lt; endl;
            create();
        }
    }


private:

    Matrix32d createPT32(){//创建一个随机的32x32 的01矩阵
        Matrix32d m5;
        Matrix2d* arrayM =  new Matrix2d[256];
        for(int i=0;i&lt;256;i++){
            arrayM[i] = create2();
        }

        m5 &lt;&lt; arrayM[0], arrayM[1], arrayM[2], arrayM[3], arrayM[4], arrayM[5], arrayM[6], arrayM[7], arrayM[8], arrayM[9], arrayM[10], arrayM[11], arrayM[12], arrayM[13], arrayM[14], arrayM[15], arrayM[16],
                arrayM[17], arrayM[18], arrayM[19], arrayM[20], arrayM[21], arrayM[22], arrayM[23], arrayM[24], arrayM[25], arrayM[26], arrayM[27], arrayM[28], arrayM[29], arrayM[30], arrayM[31], arrayM[32],
                arrayM[33], arrayM[34], arrayM[35], arrayM[36], arrayM[37], arrayM[38], arrayM[39], arrayM[40], arrayM[41], arrayM[42], arrayM[43], arrayM[44], arrayM[45], arrayM[46], arrayM[47], arrayM[48],
                arrayM[49], arrayM[50], arrayM[51], arrayM[52], arrayM[53], arrayM[54], arrayM[55], arrayM[56], arrayM[57], arrayM[58], arrayM[59], arrayM[60], arrayM[61], arrayM[62], arrayM[63], arrayM[64],
                arrayM[65], arrayM[66], arrayM[67], arrayM[68], arrayM[69], arrayM[70], arrayM[71], arrayM[72], arrayM[73], arrayM[74], arrayM[75], arrayM[76], arrayM[77], arrayM[78], arrayM[79], arrayM[80],
                arrayM[81], arrayM[82], arrayM[83], arrayM[84], arrayM[85], arrayM[86], arrayM[87], arrayM[88], arrayM[89], arrayM[90], arrayM[91], arrayM[92], arrayM[93], arrayM[94], arrayM[95], arrayM[96],
                arrayM[97], arrayM[98], arrayM[99], arrayM[100], arrayM[101], arrayM[102], arrayM[103], arrayM[104], arrayM[105], arrayM[106], arrayM[107], arrayM[108], arrayM[109], arrayM[110], arrayM[111],
                arrayM[112], arrayM[113], arrayM[114], arrayM[115], arrayM[116], arrayM[117], arrayM[118], arrayM[119], arrayM[120], arrayM[121], arrayM[122], arrayM[123], arrayM[124], arrayM[125], arrayM[126],
                arrayM[127], arrayM[128], arrayM[129], arrayM[130], arrayM[131], arrayM[132], arrayM[133], arrayM[134], arrayM[135], arrayM[136], arrayM[137], arrayM[138], arrayM[139], arrayM[140], arrayM[141],
                arrayM[142], arrayM[143], arrayM[144], arrayM[145], arrayM[146], arrayM[147], arrayM[148], arrayM[149], arrayM[150], arrayM[151], arrayM[152], arrayM[153], arrayM[154], arrayM[155], arrayM[156],
                arrayM[157], arrayM[158], arrayM[159], arrayM[160], arrayM[161], arrayM[162], arrayM[163], arrayM[164], arrayM[165], arrayM[166], arrayM[167], arrayM[168], arrayM[169], arrayM[170], arrayM[171],
                arrayM[172], arrayM[173], arrayM[174], arrayM[175], arrayM[176], arrayM[177], arrayM[178], arrayM[179], arrayM[180], arrayM[181], arrayM[182], arrayM[183], arrayM[184], arrayM[185], arrayM[186],
                arrayM[187], arrayM[188], arrayM[189], arrayM[190], arrayM[191], arrayM[192], arrayM[193], arrayM[194], arrayM[195], arrayM[196], arrayM[197], arrayM[198], arrayM[199], arrayM[200], arrayM[201],
                arrayM[202], arrayM[203], arrayM[204], arrayM[205], arrayM[206], arrayM[207], arrayM[208], arrayM[209], arrayM[210], arrayM[211], arrayM[212], arrayM[213], arrayM[214], arrayM[215], arrayM[216],
                arrayM[217], arrayM[218], arrayM[219], arrayM[220], arrayM[221], arrayM[222], arrayM[223], arrayM[224], arrayM[225], arrayM[226], arrayM[227], arrayM[228], arrayM[229], arrayM[230], arrayM[231],
                arrayM[232], arrayM[233], arrayM[234], arrayM[235], arrayM[236], arrayM[237], arrayM[238], arrayM[239], arrayM[240], arrayM[241], arrayM[242], arrayM[243], arrayM[244], arrayM[245], arrayM[246],
                arrayM[247], arrayM[248], arrayM[249], arrayM[250], arrayM[251], arrayM[252], arrayM[253], arrayM[254], arrayM[255];
        return m5;
    }

    Matrix2d create2(){//创建 2x2 的01随机矩阵
        Matrix2d m1;
        m1(0,0) = rand()%2;
        m1(1,0) = rand()%2;
        m1(0,1) = rand()%2;
        m1(1,1) = rand()%2;
        return m1;
    }

    int check(Matrix32d m){//检查是不是可逆的

        if(fabs(m.determinant())){
            return 1;
        }else{
            return 0;
        }
    }

};

int main(){
    srand((unsigned int)time(NULL));
    cM32 *m = new cM32;
    for(int i=0;i&lt;1000;i++){
        m-&gt;create();

    }
}
</code></pre></div><div class="tags"><a href="/tags/编程-C-类库/">编程 C++ 类库</a></div><div class="post-nav"><a class="pre" href="/2018/10/12/J2EE基础（Servlet篇）/">J2EE 基础（Servlet篇）</a><a class="next" href="/2018/10/11/C++ 基础教程/">C++ 基础教程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.k0rz3n.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categorías</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/APT/">APT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kerberos/">Kerberos</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/learning/">learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web安全/">web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/wireshark/">wireshark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘/">备忘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘-笔记/">备忘 笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习思考/">学习思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具使用/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞分析/">漏洞分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞研究/">漏洞研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/">论文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Etiquetas</i></div><div class="tagcloud"><a href="/tags/Fuzz-XSS/" style="font-size: 15px;">Fuzz XSS</a> <a href="/tags/APT/" style="font-size: 15px;">APT</a> <a href="/tags/备忘-反向代理-配置/" style="font-size: 15px;">备忘 反向代理 配置</a> <a href="/tags/开发-Github-备忘/" style="font-size: 15px;">开发 Github 备忘</a> <a href="/tags/配置-备忘/" style="font-size: 15px;">配置 备忘</a> <a href="/tags/Linux-渗透测试-备忘/" style="font-size: 15px;">Linux 渗透测试 备忘</a> <a href="/tags/编程-Python-进阶-备忘/" style="font-size: 15px;">编程 Python 进阶 备忘</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/网络安全-Google-Hacking-信息收集-渗透测试/" style="font-size: 15px;">网络安全 Google Hacking 信息收集 渗透测试</a> <a href="/tags/J2EE-基础/" style="font-size: 15px;">J2EE 基础</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/网络安全-Python语法/" style="font-size: 15px;">网络安全 Python语法</a> <a href="/tags/Windows-FTP搭建-备忘/" style="font-size: 15px;">Windows FTP搭建 备忘</a> <a href="/tags/learning/" style="font-size: 15px;">learning</a> <a href="/tags/gcc-备忘-笔记/" style="font-size: 15px;">gcc 备忘 笔记</a> <a href="/tags/CTF-Tools/" style="font-size: 15px;">CTF Tools</a> <a href="/tags/学习发现/" style="font-size: 15px;">学习发现</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/kali/" style="font-size: 15px;">kali</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/php语法/" style="font-size: 15px;">php语法</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/wireshark/" style="font-size: 15px;">wireshark</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/Linux-备忘/" style="font-size: 15px;">Linux 备忘</a> <a href="/tags/备忘/" style="font-size: 15px;">备忘</a> <a href="/tags/备忘-shell-Linux/" style="font-size: 15px;">备忘 shell Linux</a> <a href="/tags/网络安全-渗透测试-内网代理/" style="font-size: 15px;">网络安全 渗透测试 内网代理</a> <a href="/tags/工具使用/" style="font-size: 15px;">工具使用</a> <a href="/tags/渗透测试-局域网扫描/" style="font-size: 15px;">渗透测试 局域网扫描</a> <a href="/tags/备忘-dcoker-getshell-CTF/" style="font-size: 15px;">备忘 dcoker getshell CTF</a> <a href="/tags/渗透测试-技巧/" style="font-size: 15px;">渗透测试 技巧</a> <a href="/tags/网络安全-渗透测试-sqlmap/" style="font-size: 15px;">网络安全 渗透测试 sqlmap</a> <a href="/tags/静态检测/" style="font-size: 15px;">静态检测</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/工具-渗透测试/" style="font-size: 15px;">工具 渗透测试</a> <a href="/tags/笔记-协议分析/" style="font-size: 15px;">笔记 协议分析</a> <a href="/tags/web安全-漏洞-CTF/" style="font-size: 15px;">web安全  漏洞  CTF</a> <a href="/tags/PHP-备忘-笔记/" style="font-size: 15px;">PHP 备忘 笔记</a> <a href="/tags/渗透测试-windows-后门/" style="font-size: 15px;">渗透测试 windows 后门</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/web安全-CTF-渗透测试-PHP/" style="font-size: 15px;">web安全 CTF 渗透测试 PHP</a> <a href="/tags/CSP/" style="font-size: 15px;">CSP</a> <a href="/tags/Java-备忘-笔记/" style="font-size: 15px;">Java 备忘 笔记</a> <a href="/tags/域渗透/" style="font-size: 15px;">域渗透</a> <a href="/tags/JSONP/" style="font-size: 15px;">JSONP</a> <a href="/tags/编程-C-类库/" style="font-size: 15px;">编程 C++ 类库</a> <a href="/tags/java-备忘/" style="font-size: 15px;">java 备忘</a> <a href="/tags/web安全-CTF/" style="font-size: 15px;">web安全 CTF</a> <a href="/tags/CTF-writeup/" style="font-size: 15px;">CTF writeup</a> <a href="/tags/web安全-MySQL-渗透测试/" style="font-size: 15px;">web安全 MySQL 渗透测试</a> <a href="/tags/编程-PHP-基础/" style="font-size: 15px;">编程 PHP 基础</a> <a href="/tags/Redis-备忘/" style="font-size: 15px;">Redis 备忘</a> <a href="/tags/web安全-漏洞分析/" style="font-size: 15px;">web安全 漏洞分析</a> <a href="/tags/漏洞研究/" style="font-size: 15px;">漏洞研究</a> <a href="/tags/网络安全-钓鱼-恶意代码分析-漏洞分析/" style="font-size: 15px;">网络安全 钓鱼 恶意代码分析 漏洞分析</a> <a href="/tags/密码学-网络协议/" style="font-size: 15px;">密码学 网络协议</a> <a href="/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/tags/编程-PHP-进阶/" style="font-size: 15px;">编程 PHP 进阶</a> <a href="/tags/网络安全-沙盒逃逸-Python/" style="font-size: 15px;">网络安全 沙盒逃逸 Python</a> <a href="/tags/SQL-语法/" style="font-size: 15px;">SQL 语法</a> <a href="/tags/Fuzz/" style="font-size: 15px;">Fuzz</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/符号执行/" style="font-size: 15px;">符号执行</a> <a href="/tags/XSS/" style="font-size: 15px;">XSS</a> <a href="/tags/编程-JAVA-基础/" style="font-size: 15px;">编程 JAVA 基础</a> <a href="/tags/污点分析/" style="font-size: 15px;">污点分析</a> <a href="/tags/PHP-静态检测/" style="font-size: 15px;">PHP 静态检测</a> <a href="/tags/Windows-批处理-备忘/" style="font-size: 15px;">Windows 批处理 备忘</a> <a href="/tags/SQL-注入/" style="font-size: 15px;">SQL 注入</a> <a href="/tags/流量分析/" style="font-size: 15px;">流量分析</a> <a href="/tags/编程-C-基础/" style="font-size: 15px;">编程 C++ 基础</a> <a href="/tags/编程-进阶/" style="font-size: 15px;">编程 进阶</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recientes</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/03/Python3 爬虫知识梳理(基础篇)/">Python3 爬虫知识梳理(基础篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/29/New Page ,New Future/">New Page,New Future</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/JAVA 泛型、动态代理技术要点梳理/">JAVA 泛型、动态代理技术要点梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/TCTF 2019 线上赛 web 题 writeup/">TCTF 2019 线上赛 web 题 writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/2018 APT (Advanced Persistent Threat)攻击大事件/">2018 APT (Advanced Persistent Threat)攻击大事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/APT(高级持续威胁) 概念以及趋势概述/">APT(高级持续威胁) 概念以及趋势概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/19/威胁情报概念与APT事件分析模型概述/">威胁情报概念与APT事件分析模型概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/浅析 Kerberos 认证过程以及黄金票据和白银票据/">浅析 Kerberos 认证过程以及黄金票据和白银票据</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/C&C控制服务的设计和侦测方法综述(Drops from wooyun)/">C&C控制服务的设计和侦测方法综述(Drops from wooyun)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/如何使用 DOM XSS 来绕过 CSP 的 nonces 机制(半机翻有删增)/">如何使用 DOM XSS 来绕过 CSP 的 nonces 机制(半机翻有删增)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://math1as.com/" title="math1as" target="_blank">math1as</a><ul></ul><a href="https://www.zsxsoft.com/" title="zsx" target="_blank">zsx</a><ul></ul><a href="https://www.lorexxar.cn/" title="Lorexxar" target="_blank">Lorexxar</a><ul></ul><a href="https://chybeta.github.io/" title="Chybeta" target="_blank">Chybeta</a><ul></ul><a href="http://www.cnblogs.com/iamstudy/" title="L3m0n" target="_blank">L3m0n</a><ul></ul><a href="http://www.pupiles.com" title="pupiles" target="_blank">pupiles</a><ul></ul><a href="http://f1sh.site/" title="f1sh" target="_blank">f1sh</a><ul></ul><a href="https://www.leavesongs.com/" title="phithon" target="_blank">phithon</a><ul></ul><a href="http://sh3ll.me/" title="Chu" target="_blank">Chu</a><ul></ul><a href="https://www.virzz.com/" title="Virink" target="_blank">Virink</a><ul></ul><a href="http://blog.cal1.cn/" title="超威蓝猫" target="_blank">超威蓝猫</a><ul></ul><a href="https://ricterz.me" title="RicterZ" target="_blank">RicterZ</a><ul></ul><a href="https://cyto.top/" title="Cytosine" target="_blank">Cytosine</a><ul></ul><a href="http://foreversong.cn/" title="ADog" target="_blank">ADog</a><ul></ul><a href="http://www.ckj123.com/" title="cjk123" target="_blank">cjk123</a><ul></ul><a href="http://arch0n.sumblog.cn" title="August" target="_blank">August</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">K0rz3n's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>