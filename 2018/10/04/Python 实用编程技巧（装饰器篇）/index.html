<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content="John Doe">
    <meta name="keywords" content>
    <title>Python 实用编程技巧（装饰器篇） ~ Hexo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>Hexo</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">Python 实用编程技巧（装饰器篇）</p>
            <br>
            
            <p>Thursday, October 4th 2018, 1:14 am</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h2 id="一、如何使用函数装饰器？"><a href="#一、如何使用函数装饰器？" class="headerlink" title="一、如何使用函数装饰器？"></a><strong>一、如何使用函数装饰器？</strong></h2><h3 id="1-需求："><a href="#1-需求：" class="headerlink" title="1.需求："></a><strong>1.需求：</strong></h3><p>比如说，我们想为很多不同的函数添加相同的功能，比如说计时统计、记录日志、缓存运算结果等，但是我们又不想在每个函数中添加相同的代码</p>
<a id="more"></a>
<h3 id="2-举个例子："><a href="#2-举个例子：" class="headerlink" title="2.举个例子："></a><strong>2.举个例子：</strong></h3><p>我们还是以斐波那契数的计算为例</p>
<p><strong>示例代码：</strong></p>
<pre><code>def fib(n):
    if n &lt;= 1:
        return 1
    return fib(n-1)+fib(n-2)

if __name__ == &apos;__main__&apos;:
    print fib(50)
</code></pre><p>这一段代码想要跑出来非常的慢，因为我们在这个运算的过程中经历了非常多的重复运算，比如我们想计算50就要计算49,48 我们要计算49 就要计算 48，47 ,看到了吧，48 就出现了重复运算，那么这里面有着太多太多的重复运算，导致我们的计算非常的慢，并且非常的消耗 CPU</p>
<p><strong>那么怎么办呢？</strong></p>
<p>我们可以创造一个缓存，每次算到一个新的结果我们都放在这个缓存中，这样我们每次都判断缓存有没有我们想要的值就可以了，有的话直接拿过来用，没有再加入缓存，这样就能大大提高我们的运行效率，并且减轻了我们的CPU 的负担</p>
<p><strong>示例代码：</strong></p>
<pre><code>def fib(n,cache = None):
    if cache is None:
        cache = {}
    if n in cache:
        return cache[n]

    if n &lt;= 1:
        return 1

    cache[n] = fib(n-1,cache)+fib(n-2,cache)
    return cache[n]

if __name__ == &apos;__main__&apos;:
    print fib(50)
</code></pre><p><strong>结果：</strong></p>
<pre><code>20365011074
</code></pre><p>我们发现效率出现了质的飞跃，很快就算出了结果，但是换做别的函数我么又要添加这个缓存的代码了，这样就非常的烦，</p>
<p><strong>那么怎么解决呢？</strong></p>
<p>我们考虑创建一个包裹函数 wrap ，在这个函数内部我们实现我们的缓存代码，并且调用原函数，我们的函数装饰器就是为了生成这样的包裹函数的</p>
<p><strong>示例代码：</strong></p>
<pre><code>def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap


def fib(n):
    if n &lt;= 1:
        return 1
    return fib(n - 1) + fib(n - 2)


if __name__ == &apos;__main__&apos;:
    fib = memo(fib)
    print fib(50)
</code></pre><p><strong>结果：</strong></p>
<pre><code>20365011074
</code></pre><p>当然这样在函数中写是非常啰嗦的，我们python 给我们提供了一个语法糖，</p>
<p><strong>示例代码：</strong></p>
<pre><code>def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap

@memo
def fib(n):
    if n &lt;= 1:
        return 1
    return fib(n - 1) + fib(n - 2)


if __name__ == &apos;__main__&apos;:
    print fib(50)
</code></pre><p><strong>结果：</strong></p>
<pre><code>20365011074
</code></pre><h2 id="二、如何为被装饰的函数保存元数据"><a href="#二、如何为被装饰的函数保存元数据" class="headerlink" title="二、如何为被装饰的函数保存元数据"></a><strong>二、如何为被装饰的函数保存元数据</strong></h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h3><p>在函数对象中保存着一些函数的元数据,例如：</p>
<p><code>f.__name__</code>   函数的名字<br><code>f.__doc__</code>   函数的文档字符串<br><code>f.__model__</code>  函数所属的模块名<br><code>f.__dict__</code>   属性字典<br><code>f.__defaults__</code>  默认参数元组</p>
<p>我们在使用装饰器以后，再使用上面这些属性访问的时候，看到的是包裹函数的元数据，而原始函数的元数据不见了，我们该如何解决</p>
<h3 id="2-举个例子：-1"><a href="#2-举个例子：-1" class="headerlink" title="2.举个例子："></a><strong>2.举个例子：</strong></h3><p>下面是原始函数的返回结果</p>
<p><strong>示例代码：</strong></p>
<pre><code>def example():
    &apos;&apos;&apos;example function&apos;&apos;&apos;
    print &quot;In example&quot;

if __name__ == &apos;__main__&apos;:
    print example.__name__
    print example.__doc__
</code></pre><p><strong>结果：</strong></p>
<pre><code>example
example function
</code></pre><p>这下面是经过装饰器装饰以后的返回结果</p>
<p><strong>示例代码：</strong></p>
<pre><code>def mydecorator(func):
    def wrap(*args,**kargs):
        &apos;&apos;&apos;wrap function&apos;&apos;&apos;
        print &quot;In wrapper&quot;
        func(*args,**kargs)
    return wrap


@mydecorator
def example():
    &apos;&apos;&apos;example function&apos;&apos;&apos;
    print &quot;In example&quot;

if __name__ == &apos;__main__&apos;:
    print example.__name__
    print example.__doc__
</code></pre><p><strong>结果：</strong></p>
<pre><code>wrap
wrap function
</code></pre><p><strong>解决：</strong></p>
<p>我们使用 functools 中的 wraps 装饰内部的包裹函数，可以定义将原函数的某些属性更新到包裹函数上面</p>
<p><strong>示例代码:</strong></p>
<pre><code>from functools import wraps
def mydecorator(func):
    @wraps(func)
    def wrap(*args,**kargs):
        &apos;&apos;&apos;wrap function&apos;&apos;&apos;
        print &quot;In wrapper&quot;
        func(*args,**kargs)
    return wrap


@mydecorator
def example():
    &apos;&apos;&apos;example function&apos;&apos;&apos;
    print &quot;In example&quot;

if __name__ == &apos;__main__&apos;:
    print example.__name__
    print example.__doc__
</code></pre><p><strong>结果：</strong></p>
<pre><code>example
example function
</code></pre><h2 id="三、如何自定义带参数的装饰器"><a href="#三、如何自定义带参数的装饰器" class="headerlink" title="三、如何自定义带参数的装饰器"></a><strong>三、如何自定义带参数的装饰器</strong></h2><p>比如说我们想实现一个装饰器来检查被装饰函数的参数类型，装饰器能定义函数的参数类型，如果函数调用的时参数类型不对就抛出异常</p>
<p>带参数的装饰器就是根据参数定制化一个装饰器，可以看成是生产装饰器的工厂，每次调用这个装饰器都能返回一个特定的装饰器，然后再用其修饰其它函数</p>
<p><strong>示例代码：</strong></p>
<pre><code>from inspect import signature

def typeassert(*ty_args,**ty_kargs):
    def decorator(func):
        sig = signature(func)
        btypes = sig.bind_partial(*ty_args,**ty_kargs).arguments
        def wrapper(*args,**kargs):
            for name,obj in sig.bind(*args,**kargs).arguments.items():
                if name in btypes:
                    if not isinstance(obj,btypes[name]):
                        raise TypeError(&quot;%s must be %s&quot; % (name,btypes[name]))
            return func(*args,**kargs)
        return wrapper
    return decorator

@typeassert(int,str,list)
def f(a,b,c):
    print (a,b,c)

if __name__ == &apos;__main__&apos;:
    f(1,&quot;abc&quot;,[1,2,3])
    f(1,2,[1,2,3])
</code></pre><p><strong>结果：</strong></p>
<pre><code>1 abc [1, 2, 3]
TypeError: b must be &lt;class &apos;str&apos;&gt;
</code></pre><h2 id="四、如何实现属性可修改的装饰器"><a href="#四、如何实现属性可修改的装饰器" class="headerlink" title="四、如何实现属性可修改的装饰器"></a><strong>四、如何实现属性可修改的装饰器</strong></h2><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a><strong>背景：</strong></h3><p>为了分析程序内哪些程序开销较大，我们可以定义一个带有timeout 参数的函数装饰器，他实现以下功能：</p>
<p>1.统计被装饰的函数的单次调用的时间<br>2.时间大于timeout 的将此次函数的调用记录记录在 log 日志文件中<br>3.运行时可以修改 timeout 的值</p>
<p><strong>示例代码：</strong></p>
<pre><code>from functools import wraps
import time
import logging
from random import randint


def warn(timeout): 
    def decorator(func):
        @wraps(func)
        def wrapper(*args,**kargs):
            start = time.time()
            res = func(*args,**kargs)
            used = time.time() - start
            if used &gt; timeout:
                msg = &quot;%s : %s &gt; %s&quot; % (func.__name__,used,timeout)
                logging.warn(msg)
            return res
        return wrapper
    return decorator

@warn(1.5)
def test():
    print(&quot;In test&quot;)
    while randint(0,1):
        time.sleep(0.5)


for i in range(30):
    test()
</code></pre><p>我们可以在包裹中添加一个函数，然后用这个函数来修改闭包中的自由变量</p>
<p><strong>Python3</strong> </p>
<p><strong>示例代码：</strong></p>
<pre><code>from functools import wraps
import time
import logging
from random import randint


def warn(timeout):
    def decorator(func):
        @wraps(func)
        def wrapper(*args,**kargs):
            start = time.time()
            res = func(*args,**kargs)
            used = time.time() - start
            if used &gt; timeout:
                msg = &quot;%s : %s &gt; %s&quot; % (func.__name__,used,timeout)
                logging.warn(msg)
            return res

        def setTimeout(k):
            nonlocal timeout
            timeout = k
        wrapper.setTimeout = setTimeout

        return wrapper
    return decorator

@warn(1)
def test():
    print(&quot;In test&quot;)
    while randint(0,1):
        time.sleep(0.5)


for i in range(30):
    test()

test.setTimeout(1)
for i in range(30):
    test()
</code></pre><p>但是由于 python2 并不支持 nonlocal ，于是我们还要修改，使用列表将其修改成一个可变变量</p>
<p><strong>示例代码：</strong></p>
<pre><code>from functools import wraps
import time
import logging
from random import randint


def warn(timeout):
    timeout = [timeout]
    def decorator(func):
        @wraps(func)
        def wrapper(*args,**kargs):
            start = time.time()
            res = func(*args,**kargs)
            used = time.time() - start
            if used &gt; timeout[0]:
                msg = &quot;%s : %s &gt; %s&quot; % (func.__name__,used,timeout[0])
                logging.warn(msg)
            return res

        def setTimeout(k):
            #nonlocal timeout
            timeout[0] = k
        wrapper.setTimeout = setTimeout

        return wrapper
    return decorator

@warn(1)
def test():
    print(&quot;In test&quot;)
    while randint(0,1):
        time.sleep(0.5)


for i in range(30):
    test()

test.setTimeout(1)
for i in range(30):
    test()
</code></pre>
                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;编程 Python 进阶 备忘</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
                    <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>