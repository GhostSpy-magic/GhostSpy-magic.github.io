<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Python 编程进阶（重点在于面向对象和魔法方法） | K0rz3n's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python 编程进阶（重点在于面向对象和魔法方法）</h1><a id="logo" href="/.">K0rz3n's Blog</a><p class="description">Shell-is-Only-the-Beginning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python 编程进阶（重点在于面向对象和魔法方法）</h1><div class="post-meta">Oct 4, 2018<span> | </span><span class="category"><a href="/categories/编程/">编程</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Python-一切皆对象"><span class="toc-number">1.</span> <span class="toc-text">一、Python 一切皆对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-赋值给一个变量"><span class="toc-number">1.1.</span> <span class="toc-text">1.赋值给一个变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-添加到集合对象中"><span class="toc-number">1.2.</span> <span class="toc-text">2.添加到集合对象中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-可以作为函数的返回值"><span class="toc-number">1.3.</span> <span class="toc-text">3.可以作为函数的返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、type-和-object-的关系"><span class="toc-number">2.</span> <span class="toc-text">二、type 和 object 的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-type"><span class="toc-number">2.1.</span> <span class="toc-text">1.type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-object"><span class="toc-number">2.2.</span> <span class="toc-text">2.object</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Python-中的内置类型"><span class="toc-number">3.</span> <span class="toc-text">三、Python 中的内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-对象的三个特征"><span class="toc-number">3.1.</span> <span class="toc-text">1.对象的三个特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）身份"><span class="toc-number">3.1.1.</span> <span class="toc-text">（1）身份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）类型"><span class="toc-number">3.1.2.</span> <span class="toc-text">（2）类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）值"><span class="toc-number">3.1.3.</span> <span class="toc-text">（3）值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Python-中的魔法函数"><span class="toc-number">4.</span> <span class="toc-text">四、Python 中的魔法函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是魔法函数"><span class="toc-number">4.1.</span> <span class="toc-text">1.什么是魔法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-str-和-repr"><span class="toc-number">4.2.</span> <span class="toc-text">2.__str__ 和 __repr__</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）-str"><span class="toc-number">4.2.1.</span> <span class="toc-text">（1） __str__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-repr"><span class="toc-number">4.2.2.</span> <span class="toc-text">(2)__repr__</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Python-深入类和对象"><span class="toc-number">5.</span> <span class="toc-text">五、Python 深入类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-鸭子类型和多态"><span class="toc-number">5.1.</span> <span class="toc-text">1.鸭子类型和多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Python-中的抽象基类"><span class="toc-number">5.2.</span> <span class="toc-text">2.Python 中的抽象基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念："><span class="toc-number">5.2.1.</span> <span class="toc-text">概念：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-isinstance-和-type-的区别"><span class="toc-number">5.3.</span> <span class="toc-text">3.isinstance 和 type 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-类变量和对象变量"><span class="toc-number">5.4.</span> <span class="toc-text">4.类变量和对象变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-类和实例的属性查找顺序-mro"><span class="toc-number">5.5.</span> <span class="toc-text">4.类和实例的属性查找顺序__mro__</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）菱形继承方式"><span class="toc-number">5.5.1.</span> <span class="toc-text">（1）菱形继承方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）锥形继承方式"><span class="toc-number">5.5.2.</span> <span class="toc-text">（2）锥形继承方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-类方法、静态方法和实例方法"><span class="toc-number">5.6.</span> <span class="toc-text">5.类方法、静态方法和实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）实例方法："><span class="toc-number">5.6.1.</span> <span class="toc-text">（1）实例方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）静态方法："><span class="toc-number">5.6.2.</span> <span class="toc-text">（2）静态方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）类方法："><span class="toc-number">5.6.3.</span> <span class="toc-text">（3）类方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-数据封装和私有属性"><span class="toc-number">5.7.</span> <span class="toc-text">6.数据封装和私有属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Python-对象的自省机制"><span class="toc-number">5.8.</span> <span class="toc-text">7.Python 对象的自省机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-什么叫做自省？"><span class="toc-number">5.8.1.</span> <span class="toc-text">1. 什么叫做自省？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-super-真的是调用父类吗"><span class="toc-number">5.9.</span> <span class="toc-text">8.super 真的是调用父类吗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-为什么要这样用"><span class="toc-number">5.9.1.</span> <span class="toc-text">1.为什么要这样用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-真的是调用父类吗？"><span class="toc-number">5.9.2.</span> <span class="toc-text">2.真的是调用父类吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Python-中的-with-语句"><span class="toc-number">5.10.</span> <span class="toc-text">9.Python 中的 with 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-上下文管理器"><span class="toc-number">5.10.1.</span> <span class="toc-text">1.上下文管理器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-使用-contextlib-简化上下文管理器"><span class="toc-number">5.11.</span> <span class="toc-text">10.使用 contextlib 简化上下文管理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、自定义序列类"><span class="toc-number">6.</span> <span class="toc-text">五、自定义序列类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-序列的分类："><span class="toc-number">6.1.</span> <span class="toc-text">1.序列的分类：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-容器序列-list-、tuple-、deque"><span class="toc-number">6.1.1.</span> <span class="toc-text">(1)容器序列: list 、tuple 、deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-扁平序列：str-、bytes-、bytearray-、array-array"><span class="toc-number">6.1.2.</span> <span class="toc-text">(2)扁平序列：str 、bytes 、bytearray 、array.array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-可变序列-list-、deque-、bytearray-、array"><span class="toc-number">6.1.3.</span> <span class="toc-text">(3) 可变序列: list 、deque 、bytearray 、array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-不可变序列：-str-、tuple-、bytes"><span class="toc-number">6.1.4.</span> <span class="toc-text">(4) 不可变序列： str 、tuple 、bytes</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-序列中的魔法函数"><span class="toc-number">6.2.</span> <span class="toc-text">2.序列中的魔法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-序列中的-和-extend-的区别"><span class="toc-number">6.3.</span> <span class="toc-text">3.序列中的 + += 和 extend 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-的使用"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. + 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-的使用"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.+= 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-但是这两个实际上是有一些区别的"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.但是这两个实际上是有一些区别的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-实现可切片对象"><span class="toc-number">6.4.</span> <span class="toc-text">4.实现可切片对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-先来回顾一下切片操作"><span class="toc-number">6.4.1.</span> <span class="toc-text">1.先来回顾一下切片操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-自己构造一个可切片对象"><span class="toc-number">6.4.2.</span> <span class="toc-text">2.自己构造一个可切片对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-bisect-维持已排序的序列"><span class="toc-number">6.5.</span> <span class="toc-text">5.bisect 维持已排序的序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-什么时候我们不应该使用列表"><span class="toc-number">6.6.</span> <span class="toc-text">6.什么时候我们不应该使用列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Python-中的-set-和-dict"><span class="toc-number">7.</span> <span class="toc-text">六、Python 中的 set 和 dict</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-dict-中的常用方法"><span class="toc-number">7.1.</span> <span class="toc-text">1.dict 中的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-clear-方法："><span class="toc-number">7.1.1.</span> <span class="toc-text">(1)clear 方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-copy-方法"><span class="toc-number">7.1.2.</span> <span class="toc-text">(2)copy() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-fromkeys-方法"><span class="toc-number">7.1.3.</span> <span class="toc-text">(3)fromkeys 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-get-方法"><span class="toc-number">7.1.4.</span> <span class="toc-text">(4)get 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-items-方法"><span class="toc-number">7.1.5.</span> <span class="toc-text">(5)items 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-setdefault-方法"><span class="toc-number">7.1.6.</span> <span class="toc-text">(6)setdefault 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-update-方法"><span class="toc-number">7.1.7.</span> <span class="toc-text">(7)update 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-set-和-frozeset"><span class="toc-number">7.2.</span> <span class="toc-text">2.set 和 frozeset</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-无序"><span class="toc-number">7.2.1.</span> <span class="toc-text">(1)无序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）不重复"><span class="toc-number">7.2.2.</span> <span class="toc-text">（2）不重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）frozenset-是不可变的"><span class="toc-number">7.2.3.</span> <span class="toc-text">（3）frozenset 是不可变的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-dict-背后的实现原理"><span class="toc-number">7.3.</span> <span class="toc-text">2.dict 背后的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、对象引用、可变性和垃圾回收"><span class="toc-number">8.</span> <span class="toc-text">六、对象引用、可变性和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Python-中的变量是什么？"><span class="toc-number">8.1.</span> <span class="toc-text">1.Python 中的变量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Python-中的-和-is"><span class="toc-number">8.2.</span> <span class="toc-text">2.Python 中的 == 和 is</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）is-比较的是两个的-id"><span class="toc-number">8.2.1.</span> <span class="toc-text">（1）is 比较的是两个的 id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）-比较的是值"><span class="toc-number">8.2.2.</span> <span class="toc-text">（2）== 比较的是值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-del-和垃圾回收"><span class="toc-number">8.3.</span> <span class="toc-text">3.del 和垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、元类编程"><span class="toc-number">9.</span> <span class="toc-text">七、元类编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-property-动态属性"><span class="toc-number">9.1.</span> <span class="toc-text">1.property 动态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-getattr-和-getattribute"><span class="toc-number">9.2.</span> <span class="toc-text">2.getattr 和 getattribute</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-getattr"><span class="toc-number">9.2.1.</span> <span class="toc-text">(1)__getattr__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-getattribute"><span class="toc-number">9.2.2.</span> <span class="toc-text">(2)__getattribute__</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-属性描述符和属性的查找过程"><span class="toc-number">9.3.</span> <span class="toc-text">3.属性描述符和属性的查找过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）属性描述符："><span class="toc-number">9.3.1.</span> <span class="toc-text">（1）属性描述符：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-new-和-init-的区别"><span class="toc-number">9.4.</span> <span class="toc-text">4.__new__ 和 __init__ 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-自定义元类"><span class="toc-number">9.5.</span> <span class="toc-text">5.自定义元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、Python-的迭代器和生成器"><span class="toc-number">10.</span> <span class="toc-text">八、Python 的迭代器和生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Python-中的迭代协议："><span class="toc-number">10.1.</span> <span class="toc-text">1.Python 中的迭代协议：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Python-中迭代器和可迭代对象的区别："><span class="toc-number">10.2.</span> <span class="toc-text">2.Python 中迭代器和可迭代对象的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-回顾一下之前的代码："><span class="toc-number">10.2.1.</span> <span class="toc-text">1.回顾一下之前的代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-我们来自己实现一个迭代器："><span class="toc-number">10.2.2.</span> <span class="toc-text">2.我们来自己实现一个迭代器：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python-中的生成器函数："><span class="toc-number">10.3.</span> <span class="toc-text">3.Python 中的生成器函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-概念："><span class="toc-number">10.3.1.</span> <span class="toc-text">1.概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-看一下生成器的优势："><span class="toc-number">10.3.2.</span> <span class="toc-text">2.看一下生成器的优势：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Python-是怎么实现生成器的："><span class="toc-number">10.4.</span> <span class="toc-text">4.Python 是怎么实现生成器的：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-先来讲讲Python-是怎么实现函数调用的"><span class="toc-number">10.4.1.</span> <span class="toc-text">1.先来讲讲Python 是怎么实现函数调用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接下来介绍函数装饰器的使用"><span class="toc-number">10.4.2.</span> <span class="toc-text">接下来介绍函数装饰器的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h2 id="一、Python-一切皆对象"><a href="#一、Python-一切皆对象" class="headerlink" title="一、Python 一切皆对象"></a><strong>一、Python 一切皆对象</strong></h2><p>Python 的一切皆对象是非常彻底的，不管是函数还是类，都是对象，对象就有一些独特的特性</p>
<p>1.赋值给一个变量<br>2.可以添加到集合对象中<br>3.都能作为函数的参数进行传递<br>4.都能当做函数的返回值<br><a id="more"></a></p>
<h3 id="1-赋值给一个变量"><a href="#1-赋值给一个变量" class="headerlink" title="1.赋值给一个变量"></a><strong>1.赋值给一个变量</strong></h3><p><strong>(1)函数赋值给一个变量</strong></p>
<p><strong>示例代码:</strong></p>
<pre><code>def add(name = &quot;K0rz3n&quot;):
    print name

object_test = add
object_test()
</code></pre><p><strong>(2)类赋值给一个变量</strong></p>
<pre><code>class Person():
    def __init__(self):
        print &quot;K0rz3n&quot;

class_test = Person
class_test()
</code></pre><h3 id="2-添加到集合对象中"><a href="#2-添加到集合对象中" class="headerlink" title="2.添加到集合对象中"></a><strong>2.添加到集合对象中</strong></h3><pre><code>def add(name = &quot;K0rz3n&quot;):
    print name

class Person():
    def __init__(self):
        print &quot;K0rz3n&quot;

obj_list = []
obj_list.append(add)
obj_list.append(Person)

for item in obj_list:
    print item()
</code></pre><p><strong>结果：</strong></p>
<pre><code>K0rz3n
None
K0rz3n
&lt;__main__.Person instance at 0x0000000003277E08&gt;
</code></pre><h3 id="3-可以作为函数的返回值"><a href="#3-可以作为函数的返回值" class="headerlink" title="3.可以作为函数的返回值"></a><strong>3.可以作为函数的返回值</strong></h3><p>函数作为返回值其实是 python 装饰器的精髓</p>
<p><strong>示例代码：</strong></p>
<pre><code>def add(name = &quot;K0rz3n&quot;):
    print name

class Person():
    def __init__(self):
        print &quot;K0rz3n&quot;

def decorator():
    print &quot;dec success&quot;
    return add

test = decorator()
test()
</code></pre><p><strong>结果：</strong></p>
<pre><code>dec success
K0rz3n
</code></pre><h2 id="二、type-和-object-的关系"><a href="#二、type-和-object-的关系" class="headerlink" title="二、type 和 object 的关系"></a><strong>二、type 和 object 的关系</strong></h2><h3 id="1-type"><a href="#1-type" class="headerlink" title="1.type"></a><strong>1.type</strong></h3><p><strong>type 这个类实例化了一切，包括 object 和 他自己</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>&gt;&gt;&gt; type(1)
&lt;class &apos;int&apos;&gt;

&gt;&gt;&gt; type(int)
&lt;class &apos;type&apos;&gt;

&gt;&gt;&gt; type(type)
&lt;class &apos;type&apos;&gt;

&gt;&gt;&gt; type(object)
&lt;class &apos;type&apos;&gt;
</code></pre><p>可以看到，1 是由 int 这个类生成的对象，int 这个类是由type 这个类生成的对象</p>
<p><strong>结论：</strong></p>
<pre><code>type-&gt;class-&gt;obj
</code></pre><h3 id="2-object"><a href="#2-object" class="headerlink" title="2.object"></a><strong>2.object</strong></h3><p>object 是最顶层的基类，<strong>所有的类都继承了Object，包括type</strong> </p>
<p><strong>示例代码:</strong></p>
<pre><code>&gt;&gt;&gt; class Student():
...     pass
...
&gt;&gt;&gt; Student.__bases__
(&lt;class &apos;object&apos;&gt;,)

&gt;&gt;&gt; type.__bases__
(&lt;class &apos;object&apos;&gt;,)

&gt;&gt;&gt; object.__bases__
()
</code></pre><p>但是 object 是由 type 实例化的</p>
<p><strong>示例代码：</strong></p>
<pre><code>&gt;&gt;&gt; type(object)
&lt;class &apos;type&apos;&gt;
</code></pre><p><strong>总结：</strong></p>
<p>type 实例化了一切，包括 object 和他自己,object 是所有类的基类（最顶层，包括type）。于是乎 Type 和 object 就形成了一个回路，<strong>这其实也就是python 中类也是对象的原因（不仅继承了object 还是type 这个类的实例）</strong></p>
<h2 id="三、Python-中的内置类型"><a href="#三、Python-中的内置类型" class="headerlink" title="三、Python 中的内置类型"></a><strong>三、Python 中的内置类型</strong></h2><h3 id="1-对象的三个特征"><a href="#1-对象的三个特征" class="headerlink" title="1.对象的三个特征"></a><strong>1.对象的三个特征</strong></h3><h4 id="（1）身份"><a href="#（1）身份" class="headerlink" title="（1）身份"></a><strong>（1）身份</strong></h4><p>我们把身份理解成对象在内存中的地址</p>
<p>我们可以通过id()这个函数查看一个对象在内存中的地址</p>
<p><strong>示例代码:</strong></p>
<pre><code>&gt;&gt;&gt; a= 1
&gt;&gt;&gt; id(a)
1465347104
&gt;&gt;&gt; a = []
&gt;&gt;&gt; id(a)
2406326173512
</code></pre><h4 id="（2）类型"><a href="#（2）类型" class="headerlink" title="（2）类型"></a><strong>（2）类型</strong></h4><p>比如有：</p>
<p><strong>None （全局唯一）</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>&gt;&gt;&gt; a =None
&gt;&gt;&gt; b = None
&gt;&gt;&gt; id(a)
1464902800
&gt;&gt;&gt; id(b)
1464902800
</code></pre><p>可以看到两个变量都是指向了一个地址，说明其是全局唯一的</p>
<p><strong>数值</strong></p>
<p>Int、float、bool、complex…</p>
<p><strong>迭代类型</strong></p>
<p>可以遍历的</p>
<p><strong>序列类型</strong></p>
<p>list 、tuple 、str 、array 、range 、bytes… </p>
<p><strong>映射（dict）</strong></p>
<p>相当于字典，有 Key 和 value </p>
<p><strong>集合</strong></p>
<p>set 和 forzenset</p>
<p><strong>上下文管理器</strong></p>
<p>with 语句</p>
<p><strong>其他</strong></p>
<p>模块类型、class和实例、函数类型、方法类型、代码类型 、object 对象 、type 类型、ellipsis 类型</p>
<p>Python 有些类型是隐式的，<strong>主要是通过对象内置的魔法方法来判断对象是什么类型</strong>，这其实就是Python魔法方法的精髓，这在我们后面会详细的讲到</p>
<h4 id="（3）值"><a href="#（3）值" class="headerlink" title="（3）值"></a><strong>（3）值</strong></h4><p>这个我就不再细说了，相信大家都懂</p>
<h2 id="四、Python-中的魔法函数"><a href="#四、Python-中的魔法函数" class="headerlink" title="四、Python 中的魔法函数"></a><strong>四、Python 中的魔法函数</strong></h2><h3 id="1-什么是魔法函数"><a href="#1-什么是魔法函数" class="headerlink" title="1.什么是魔法函数"></a><strong>1.什么是魔法函数</strong></h3><p>1.Python中为我们提供的以双下划线开头和结尾的函数<br>2.魔法函数属于全局，在我们自定义的任意一个类中我们能添加任意一个魔法函数，来让这个类有着不同的性质（来增强这个类的特性，<strong>简单的说就相当于给这个类安装了一个插件</strong>）</p>
<p>在我们没有定义魔法函数之前，我们想遍历这个类中的员工，我们需要像这样写</p>
<p><strong>示例代码：</strong></p>
<pre><code>class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list

company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])
employ = company.employ
for item in employ:
    print item
</code></pre><p><strong>结果：</strong></p>
<pre><code>Tom
Alice
Bob
</code></pre><p>但是我们在定义了一个魔法方法以后事情就变得非常的简单</p>
<p><strong>示例代码：</strong></p>
<pre><code>class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list

    def __getitem__(self, item):
        return self.employ[item]

company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])
for item in company:
    print item
</code></pre><p><strong>结果：</strong></p>
<pre><code>Tom
Alice
Bob
</code></pre><p><strong>解释：</strong></p>
<p>实际上我们定义了 <code>__getitem__</code> 这个魔法方法以后，这个类实例化出来的对象就是一个可迭代的对象</p>
<h3 id="2-str-和-repr"><a href="#2-str-和-repr" class="headerlink" title="2.__str__ 和 __repr__"></a><strong>2.<code>__str__</code> 和 <code>__repr__</code></strong></h3><h4 id="（1）-str"><a href="#（1）-str" class="headerlink" title="（1） __str__"></a><strong>（1） <code>__str__</code></strong></h4><p>Python 在使用 print 的时候会隐式的调用 str() 这个函数，而这个函数会隐式的调用  <code>__str__</code> 这个魔法方法,比如我们想改变一个对象的默认输出格式，我们就需要在实例化这个对象的类中重写 <code>__str__</code>方法</p>
<p><strong>示例代码：</strong></p>
<pre><code>class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list

    def __str__(self):
        return &apos;,&apos;.join(self.employ)

company = Company([&quot;Tom&quot;,&quot;Alice&quot;,&quot;Bob&quot;])
print company
</code></pre><p><strong>结果：</strong></p>
<pre><code>Tom,Alice,Bob
</code></pre><p>`</p>
<h4 id="2-repr"><a href="#2-repr" class="headerlink" title="(2)__repr__"></a><strong>(2)<code>__repr__</code></strong></h4><p><code>__repr__</code> 是开发者模式下（交互式Python解释器中在直接写某个对象的时候会调用的函数），我们平时直接把对象写在交互式解析器中的时候会输出一些尖括号包裹的类或者对象就是隐式调用这个函数的结果，如果我们重写了这个魔法方法就能改变输出，这个和 上面的例子是一样的，我就不再重新写代码</p>
<h2 id="五、Python-深入类和对象"><a href="#五、Python-深入类和对象" class="headerlink" title="五、Python 深入类和对象"></a><strong>五、Python 深入类和对象</strong></h2><h3 id="1-鸭子类型和多态"><a href="#1-鸭子类型和多态" class="headerlink" title="1.鸭子类型和多态"></a><strong>1.鸭子类型和多态</strong></h3><p>一个对象如果他 走起来 叫起来 看起来 都像一个鸭子那我们就把他看成是一个鸭子，其实意思就是说我们关注的是这个对象内部实现了什么方法，实现的方法决定了我们将其看成是什么</p>
<p>1.比如extend(),它里面并没有要求传入某一个具体的类型，而是要求传入一个可迭代对象，所以很多的类型都是可以的</p>
<p>2.再比如，我们实现多态的时候并不像JAVA一样要求全部继承同一个类，python 只要内部实现同一个方法就可以了，到时候直接赋值调用就ok</p>
<p><strong>示例代码:</strong></p>
<pre><code>class Cat(object):
    def say(self):
        print &quot;i am a cat\n&quot;

class Dog(object):
    def say(self):
        print &quot;i am a dog\n&quot;

animal = [Cat,Dog]
for i in animal:
    i().say()
</code></pre><p><strong>结果：</strong></p>
<pre><code>i am a cat

i am a dog
</code></pre><h3 id="2-Python-中的抽象基类"><a href="#2-Python-中的抽象基类" class="headerlink" title="2.Python 中的抽象基类"></a><strong>2.Python 中的抽象基类</strong></h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h4><p>可以把 Python 的抽象基类看成是 java 中的接口，java 不能实现多继承单数能实现多个接口，接口在 java 中是不能实例化的，同样抽象基类在 Python 中也是不能实例化的（我们可以继承抽象基类，然后去实例化抽象基类的所有方法）</p>
<p>但是我们不是说过，python 是一种动态语言，<strong>动态语言是没有变量的类型的</strong>，Python中变量只是一个符号而已，他可以指向任何类型的对象。</p>
<p><strong>那么我们为什么还需要有抽象基类这个概念呢？</strong></p>
<p>1.因为我们在有些时候想判断某一个对象的类型，而不是通过一个一个的魔法函数的检验去查看对象的属性如何，这样的体验非常不好，我们提供抽象基类实际上就是提供一种类型（属性）的打包</p>
<p>2.我们在某些时候需要强制某些子类必须实现某些方法</p>
<p><strong>示例代码：</strong></p>
<pre><code>class CacheBase():
    def get(self,key):
        raise NotImplemented
    def set(self,key,value):
        raise NotImplemented

class cache(CacheBase):
   pass

my_cache = cache()
my_cache.get(&quot;key&quot;)
</code></pre><p><strong>结果：</strong></p>
<pre><code>TypeError: exceptions must be old-style classes or derived from BaseException, not NotImplementedType
</code></pre><p>当然我们如果想在实例化的时候就抛出异常的话就需要用到abc 模块以及装饰器的操作，这里不再多介绍</p>
<h3 id="3-isinstance-和-type-的区别"><a href="#3-isinstance-和-type-的区别" class="headerlink" title="3.isinstance 和 type 的区别"></a><strong>3.isinstance 和 type 的区别</strong></h3><p>这两个函数都是查看对象的归属的，但是 isinstacne() 会根据继承关系不断的向上递推，直到最顶层为止，但是 Type() 只能向上递推一个</p>
<p><strong>另外 == 和 is 不要乱用</strong></p>
<p>== 代表的是返回值是不是相等<br>is 查看的是 id() 的结果是不是相等</p>
<h3 id="4-类变量和对象变量"><a href="#4-类变量和对象变量" class="headerlink" title="4.类变量和对象变量"></a><strong>4.类变量和对象变量</strong></h3><p><strong>示例代码：</strong></p>
<pre><code>class A:
    aa = 1
    def __init__(self,x,y):
        self.x = x
        self.y = y

a = A(2,3)
print a.x,a.y,a.aa
print A.aa
</code></pre><p> <strong>结果：</strong></p>
<pre><code>2 3 1
1
</code></pre><p>这里 aa 就是类变量，那么为什么我们能打印出来呢？因为我们在寻找实例的属性的时候如果找不到就会自动的向上搜索</p>
<p><strong>还有一个比较神奇的地方</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>class A:
    aa = 1
    def __init__(self,x,y):
        self.x = x
        self.y = y

a = A(2,3)
A.aa = 10
a.aa = 100
print A.aa
print a.aa
</code></pre><p><strong>结果：</strong></p>
<pre><code>10
100
</code></pre><p>可以看到我们在实例中修改了 aa 的值，但是我们在类中访问却依然没改变，这是为什么呢？</p>
<blockquote>
<p><strong>解释：</strong></p>
<p>我们使用 a.aa<br>访问或者赋值的时候实际上会在我们的实例中新建一个属性，我们访问或者修改的都是这个新的属性，这个属性初始值和类的一样，但是他们有着不用的地址空间，因此修改后互不影响</p>
</blockquote>
<h3 id="4-类和实例的属性查找顺序-mro"><a href="#4-类和实例的属性查找顺序-mro" class="headerlink" title="4.类和实例的属性查找顺序__mro__"></a><strong>4.类和实例的属性查找顺序<code>__mro__</code></strong></h3><p>在历史上 python 设置了很多的查找算法，比如 DFS BFS 等，但是依然不能用单纯的一个方法解决所有的问题，于是后来出现了 C3 算法，这个算法比较复杂，能针对不同的模式调整查找顺序</p>
<h4 id="（1）菱形继承方式"><a href="#（1）菱形继承方式" class="headerlink" title="（1）菱形继承方式"></a><strong>（1）菱形继承方式</strong></h4><p><strong>实例代码：</strong></p>
<pre><code>class D(object):
    pass


class C(D):
    pass


class B(D):
    pass


class A(B, C):
    pass


print A.__mro__
</code></pre><p><strong>结果：</strong></p>
<pre><code>(&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;type &apos;object&apos;&gt;)
</code></pre><p><strong>解释：</strong></p>
<p>可见这种继承方式使用的是 BFS </p>
<h4 id="（2）锥形继承方式"><a href="#（2）锥形继承方式" class="headerlink" title="（2）锥形继承方式"></a><strong>（2）锥形继承方式</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>class E(object):
    pass

class D(object):
    pass


class C(E):
    pass


class B(D):
    pass


class A(B, C):
    pass


print A.__mro__
</code></pre><p><strong>结果：</strong></p>
<pre><code>(&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.E&apos;&gt;, &lt;type &apos;object&apos;&gt;)
</code></pre><p><strong>解释：</strong></p>
<p>可见这种结构的继承方式使用的是 DFS </p>
<h3 id="5-类方法、静态方法和实例方法"><a href="#5-类方法、静态方法和实例方法" class="headerlink" title="5.类方法、静态方法和实例方法"></a><strong>5.类方法、静态方法和实例方法</strong></h3><h4 id="（1）实例方法："><a href="#（1）实例方法：" class="headerlink" title="（1）实例方法："></a><strong>（1）实例方法：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    def __str__(self):
        return &quot;{year}/{month}/{day}&quot;.format(year = self.year,month = self.month,day = self.day)

new_day = Date(2018,10,2)
print new_day
</code></pre><p><strong>结果：</strong></p>
<pre><code>2018/10/2
</code></pre><p>但是如果我们有这样的需求，我们输入 2018-10-2 也能直接解析怎么办，这个时候我们就需要使用静态方法</p>
<h4 id="（2）静态方法："><a href="#（2）静态方法：" class="headerlink" title="（2）静态方法："></a><strong>（2）静态方法：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    @staticmethod
    def parse_fro_string(data_str):
        year,month,day = tuple(data_str.split(&apos;-&apos;))
        return Date(int(year),int(month),int(day))


    def __str__(self):
        return &quot;{year}/{month}/{day}&quot;.format(year = self.year,month = self.month,day = self.day)


new_day = Date.parse_fro_string(&quot;2018-10-2&quot;)
print new_day
</code></pre><p><strong>结果：</strong></p>
<pre><code>2018/10/2
</code></pre><p>但是，这个还有一个问题，就是静态方法是硬编码的，如果我们的类的名字改了，静态方法也要改，这很不好，于是我们就引出了类方法</p>
<h4 id="（3）类方法："><a href="#（3）类方法：" class="headerlink" title="（3）类方法："></a><strong>（3）类方法：</strong></h4><pre><code>class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    @staticmethod
    def parse_fro_string(data_str):
        year,month,day = tuple(data_str.split(&apos;-&apos;))
        return Date(int(year),int(month),int(day))

    @classmethod
    def fro_string(cls,data_str):
        year, month, day = tuple(data_str.split(&apos;-&apos;))
        return cls(int(year), int(month), int(day))


    def __str__(self):
        return &quot;{year}/{month}/{day}&quot;.format(year = self.year,month = self.month,day = self.day)

new_day = Date.fro_string(&quot;2018-10-2&quot;)
print new_day
</code></pre><p><strong>结果：</strong></p>
<pre><code>2018/10/2
</code></pre><h3 id="6-数据封装和私有属性"><a href="#6-数据封装和私有属性" class="headerlink" title="6.数据封装和私有属性"></a><strong>6.数据封装和私有属性</strong></h3><p>python 不像 java 有 Private 或者 protetced 这种，那么 Python 是怎么实现私有属性的</p>
<p><strong>示例代码：</strong></p>
<pre><code> class Date():
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day

    @staticmethod
    def parse_fro_string(data_str):
        year,month,day = tuple(data_str.split(&apos;-&apos;))
        return Date(int(year),int(month),int(day))

    @classmethod
    def fro_string(cls,data_str):
        year, month, day = tuple(data_str.split(&apos;-&apos;))
        return cls(int(year), int(month), int(day))


    def __str__(self):
        return &quot;{year}/{month}/{day}&quot;.format(year = self.year,month = self.month,day = self.day)

class User:
    def __init__(self,birthday):
        self.birthday = birthday

    def get_age(self):
        return 2018-self.birthday.year

if __name__ == &apos;__main__&apos;:
    user = User(Date(1990,2,1))
    print user.get_age()
    print user.birthday
</code></pre><p><strong>结果:</strong></p>
<pre><code>28
1990/2/1
</code></pre><p>在这种情况下，我们可以直接访问到用户的生日，如果我们不想直接访问到怎么办？我们可以在属性前面加上双下划线来解决</p>
<p><strong>示例代码：</strong></p>
<pre><code>class User:
    def __init__(self,birthday):
        self.__birthday = birthday

    def get_age(self):
        return 2018-self.__birthday.year

if __name__ == &apos;__main__&apos;:
    user = User(Date(1990,2,1))
    print user.get_age()
    print user.__birthday
</code></pre><p>可以测试一下 get_age 这个函数还是可以使用的但是 直接访问会出错</p>
<p>但是实际上这个是可以绕过的,python 只是将其做了一个变形而已,变成了  _User__birthday</p>
<p><strong>示例代码：</strong></p>
<pre><code>class User:
    def __init__(self,birthday):
        self.__birthday = birthday

    def get_age(self):
        return 2018-self.__birthday.year

if __name__ == &apos;__main__&apos;:
    user = User(Date(1990,2,1))
    print user.get_age()
    print user._User__birthday
</code></pre><p>这样就又能正常访问了</p>
<h3 id="7-Python-对象的自省机制"><a href="#7-Python-对象的自省机制" class="headerlink" title="7.Python 对象的自省机制"></a><strong>7.Python 对象的自省机制</strong></h3><h4 id="1-什么叫做自省？"><a href="#1-什么叫做自省？" class="headerlink" title="1. 什么叫做自省？"></a><strong>1. 什么叫做自省？</strong></h4><p>自省就是通过一定的机制来查看对象的内部结构（看看自己是什么东西…自我认识一下）</p>
<p><strong>示例代码：</strong></p>
<pre><code>class Person():
    name = &quot;user&quot;

class Student(Person):
    def __init__(self,school_name):
        self.school_name = school_name

if __name__ == &apos;__main__&apos;:
    user = Student(&quot;K0rz3n&quot;)
    print user.__dict__
    print Person.__dict__
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;school_name&apos;: &apos;K0rz3n&apos;}
{&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;user&apos;, &apos;__doc__&apos;: None}
</code></pre><p>除了使用 <code>__dict__</code> 以外我们还能使用 dir() 这个函数，这个函数功能更加强大，能列出对象的所有属性</p>
<p><strong>示例代码：</strong></p>
<pre><code>class Person():
    name = &quot;user&quot;

class Student(Person):
    def __init__(self,school_name):
        self.school_name = school_name

if __name__ == &apos;__main__&apos;:
    user = Student(&quot;K0rz3n&quot;)
    print user.__dict__
    print Person.__dict__
    print dir(user)
    print dir(Person)
</code></pre><p><strong>结果:</strong></p>
<pre><code>{&apos;school_name&apos;: &apos;K0rz3n&apos;}
{&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;user&apos;, &apos;__doc__&apos;: None}
[&apos;__doc__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;name&apos;, &apos;school_name&apos;]
[&apos;__doc__&apos;, &apos;__module__&apos;, &apos;name&apos;]
</code></pre><h3 id="8-super-真的是调用父类吗"><a href="#8-super-真的是调用父类吗" class="headerlink" title="8.super 真的是调用父类吗"></a><strong>8.super 真的是调用父类吗</strong></h3><p>我们可以在 B中用super()函数调用了父类 A 中的构造方法</p>
<p><strong>示例代码：</strong></p>
<pre><code>class A(object):
    def __init__(self):
        print &quot;a&quot;

class B(A):
    def __init__(self):
        super(B,self).__init__()
        print &quot;b&quot;

if __name__ ==  &apos;__main__&apos;:

    b = B()
</code></pre><p><strong>结果：</strong></p>
<pre><code>a
b
</code></pre><h4 id="1-为什么要这样用"><a href="#1-为什么要这样用" class="headerlink" title="1.为什么要这样用"></a><strong>1.为什么要这样用</strong></h4><p>有时候我们可以通过这种方式来重用父类的方法，而不是重写</p>
<h4 id="2-真的是调用父类吗？"><a href="#2-真的是调用父类吗？" class="headerlink" title="2.真的是调用父类吗？"></a><strong>2.真的是调用父类吗？</strong></h4><p>我们来做一个实验</p>
<p><strong>示例代码：</strong></p>
<pre><code>class A(object):
    def __init__(self):
        print &quot;a&quot;

class B(A):
    def __init__(self):
        print &quot;b&quot;

        super(B,self).__init__()

class C(A):
    def __init__(self):
        print &quot;c&quot;
        super(C,self).__init__()


class D(B,C):
    def __init__(self):
        print &quot;d&quot;
        super(D,self).__init__()


if __name__ ==  &apos;__main__&apos;:

    b = D()
</code></pre><p><strong>结果：</strong></p>
<pre><code>d
b
c
a
</code></pre><p><strong>解释:</strong></p>
<p>我们看到当我们调用到 B 的时候，super 并没有去找B 的父类A 而是转向了C ，这说明我们单纯的将 super 理解为寻找父类是不正确的，其实这个顺序是我们之前讲的 mro</p>
<h3 id="9-Python-中的-with-语句"><a href="#9-Python-中的-with-语句" class="headerlink" title="9.Python 中的 with 语句"></a><strong>9.Python 中的 with 语句</strong></h3><p>with 语句是用来使用上下文管理器的，那么什么叫做上下文管理器呢？</p>
<h4 id="1-上下文管理器"><a href="#1-上下文管理器" class="headerlink" title="1.上下文管理器"></a><strong>1.上下文管理器</strong></h4><p>介绍这个概念就涉及到我们之前说的魔法函数，只要拥有<code>__enter__</code> 和  <code>__exit__</code> 这两个属性的类实例化的对象就可以作为上下文管理器</p>
<p>我们可以举例看一下</p>
<p><strong>示例代码：</strong></p>
<pre><code>class Sample(object):
    def __enter__(self):
        print &quot;enter&quot;
        return self # 注意这句话绝对不能少，要不然sample 根本得不到这个对象的实例
    def __exit__(self, exc_type, exc_val, exc_tb):
        print &quot;exit&quot;
    def do_something(self):
        print &quot;do_something&quot;

with Sample() as sample:
    sample.do_something()
</code></pre><p><strong>结果:</strong></p>
<pre><code>enter
do_something
exit
</code></pre><p><strong>解释：</strong></p>
<p>可以看到，<code>__enter__</code> 和 <code>__exit__</code> 魔法函数会在调用和结束的时候自动运行，同时，拥有这两个魔法函数的类可以用 with 语句进行实例化，成为一个上下文管理器，我们可以在 <code>__enter__</code> 中创建资源，在 <code>__exit__</code> 中释放</p>
<h3 id="10-使用-contextlib-简化上下文管理器"><a href="#10-使用-contextlib-简化上下文管理器" class="headerlink" title="10.使用 contextlib 简化上下文管理器"></a><strong>10.使用 contextlib 简化上下文管理器</strong></h3><p><strong>实例代码：</strong></p>
<pre><code>import contextlib

@contextlib.contextmanager
def file_open(file_name):
    print &quot;file_open&quot;  # 这里写的是 __enter__ 中的代码
    yield{}
    print &quot;file_close&quot; # 这里写的是 __exit__ 中的代码


with file_open(&quot;test.txt&quot;) as f:
    print &quot;test&quot;
</code></pre><p><strong>结果：</strong></p>
<pre><code>file_open
test
file_close
</code></pre><h2 id="五、自定义序列类"><a href="#五、自定义序列类" class="headerlink" title="五、自定义序列类"></a><strong>五、自定义序列类</strong></h2><h3 id="1-序列的分类："><a href="#1-序列的分类：" class="headerlink" title="1.序列的分类："></a><strong>1.序列的分类：</strong></h3><h4 id="1-容器序列-list-、tuple-、deque"><a href="#1-容器序列-list-、tuple-、deque" class="headerlink" title="(1)容器序列: list 、tuple 、deque"></a><strong>(1)容器序列: list 、tuple 、deque</strong></h4><p>容器序列中可以放置任何的数据类型</p>
<h4 id="2-扁平序列：str-、bytes-、bytearray-、array-array"><a href="#2-扁平序列：str-、bytes-、bytearray-、array-array" class="headerlink" title="(2)扁平序列：str 、bytes 、bytearray 、array.array"></a><strong>(2)扁平序列：str 、bytes 、bytearray 、array.array</strong></h4><p>该序列中只有一钟类型</p>
<h4 id="3-可变序列-list-、deque-、bytearray-、array"><a href="#3-可变序列-list-、deque-、bytearray-、array" class="headerlink" title="(3) 可变序列: list 、deque 、bytearray 、array"></a><strong>(3) 可变序列: list 、deque 、bytearray 、array</strong></h4><h4 id="4-不可变序列：-str-、tuple-、bytes"><a href="#4-不可变序列：-str-、tuple-、bytes" class="headerlink" title="(4) 不可变序列： str 、tuple 、bytes"></a><strong>(4) 不可变序列： str 、tuple 、bytes</strong></h4><h3 id="2-序列中的魔法函数"><a href="#2-序列中的魔法函数" class="headerlink" title="2.序列中的魔法函数"></a><strong>2.序列中的魔法函数</strong></h3><p><code>__len__</code> 有这个方法就能实现计算长度 </p>
<p><code>__iter__</code> 有这个方法就能实现迭代</p>
<p><code>__container__</code> 有这个方法就能实现使用in判断元素是否存在</p>
<p>等等</p>
<p>我们如果要自定义序列类型就要去实现这些函数</p>
<h3 id="3-序列中的-和-extend-的区别"><a href="#3-序列中的-和-extend-的区别" class="headerlink" title="3.序列中的 + += 和 extend 的区别"></a><strong>3.序列中的 + += 和 extend 的区别</strong></h3><h4 id="1-的使用"><a href="#1-的使用" class="headerlink" title="1. + 的使用"></a><strong>1. + 的使用</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = [1,2]
c = a +[3,4]
print c
</code></pre><p><strong>结果：</strong></p>
<h4 id="2-的使用"><a href="#2-的使用" class="headerlink" title="2.+= 的使用"></a><strong>2.+= 的使用</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = [1,2]
a += [3,4]
print a 
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 2, 3, 4]
</code></pre><h4 id="3-但是这两个实际上是有一些区别的"><a href="#3-但是这两个实际上是有一些区别的" class="headerlink" title="3.但是这两个实际上是有一些区别的"></a><strong>3.但是这两个实际上是有一些区别的</strong></h4><p><strong>（1）区别一： += 是直接在 a 上进行操作</strong><br>这个就不用多解释了</p>
<p><strong>(2)区别二：+= 可以扩展不同类型的可迭代对象</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>a = [1,2]
a += (3,4)
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 2, 3, 4]
</code></pre><p>我们发现+=的神奇特性，实际上，+=底层调用的是 extend()方法，这个方法实际上在调用for 循环，因此支持for 循环的都能添加去</p>
<p><strong>还有一点就是人们经常把 append() 和 extend() 混淆</strong></p>
<p>append(） 会将参数直接放进列表中</p>
<p><strong>示例代码：</strong></p>
<pre><code>a = [1,2]
a.append([3,4])
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 2, [3, 4]]
</code></pre><h3 id="4-实现可切片对象"><a href="#4-实现可切片对象" class="headerlink" title="4.实现可切片对象"></a><strong>4.实现可切片对象</strong></h3><h4 id="1-先来回顾一下切片操作"><a href="#1-先来回顾一下切片操作" class="headerlink" title="1.先来回顾一下切片操作"></a><strong>1.先来回顾一下切片操作</strong></h4><p>模式： [start:end:step]</p>
<p>start 意思是起始位置，默认是0<br>end 意思是结束的位置，默认是列表的长度<br>step 默认是1</p>
<blockquote>
<p><strong>注意：</strong><br>1.当step 是负数的时候代表反向切片，这个时候 start 要比 end 来的大<br>2.切片返回的是一个新的元素而不会改变原来列表的值<br>3.步长为2表示包括自己在内数两个，也就是隔一个取一个</p>
</blockquote>
<p><strong>实例:</strong></p>
<p>在末尾插入一个元素</p>
<pre><code>a[len(a):] = [1] 
</code></pre><p>在开头插入一个元素</p>
<pre><code>a[:0] = [1]
</code></pre><p>在特定位置插入一个元素</p>
<pre><code>a[3:3] = [1]
</code></pre><p>隔一个修改一个</p>
<pre><code>a[::2] = [0]*3
</code></pre><p>隔一个删除一个</p>
<pre><code>del a[::2]
</code></pre><h4 id="2-自己构造一个可切片对象"><a href="#2-自己构造一个可切片对象" class="headerlink" title="2.自己构造一个可切片对象"></a><strong>2.自己构造一个可切片对象</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>import numbers
class Group():
    def __init__(self,group_name,company_name,staffs):
        self.group_name = group_name
        self.company_name = company_name
        self.staffs = staffs


    def __getitem__(self, item):
        cls = type(self)
        if isinstance(item,slice):
            return cls(group_name=self.group_name,company_name=self.company_name,staffs=self.staffs[item])
        elif isinstance(item,numbers.Integral):
            return cls(group_name=self.group_name,company_name=self.company_name,staffs=[self.staffs[item]])


staffs = [&quot;Alice&quot;,&quot;Bob&quot;,&quot;Tom&quot;,&quot;Kali&quot;]
group = Group(company_name=&quot;K0rz3n&quot;,group_name=&quot;user&quot;,staffs=staffs)
sub_group = group[1:2]
sub_group = group[0]
</code></pre><p>这个代码我本地也没有实现，会报错，还有待解决</p>
<h3 id="5-bisect-维持已排序的序列"><a href="#5-bisect-维持已排序的序列" class="headerlink" title="5.bisect 维持已排序的序列"></a><strong>5.bisect 维持已排序的序列</strong></h3><p>bisect 能维持一个已经排序好的序列（以升序排序）</p>
<p><strong>示例代码：</strong></p>
<pre><code>import bisect

inter_list = []
bisect.insort(inter_list,2)
bisect.insort(inter_list,5)
bisect.insort(inter_list,1)
bisect.insort(inter_list,6)
bisect.insort(inter_list,3)
bisect.insort(inter_list,4)

print inter_list
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre><p>我们还能查看某个元素应该插入什么位置</p>
<p><strong>示例代码：</strong></p>
<pre><code>print bisect.bisect(inter_list,3)
</code></pre><p><strong>结果：</strong></p>
<pre><code>3
</code></pre><h3 id="6-什么时候我们不应该使用列表"><a href="#6-什么时候我们不应该使用列表" class="headerlink" title="6.什么时候我们不应该使用列表"></a><strong>6.什么时候我们不应该使用列表</strong></h3><p>array 相当于 C语言的数组，在数据处理中的效率是非常高的，但是我们要注意 array 中存放的只能是一种数据类型，我们在声明的时候就要指定</p>
<p><strong>示例代码：</strong></p>
<pre><code>import array

my_array = array.array(&quot;i&quot;)
my_array.append(1)
my_array.append(2)
print my_array
</code></pre><p><strong>结果：</strong></p>
<pre><code>array(&apos;i&apos;, [1, 2])
</code></pre><h2 id="六、Python-中的-set-和-dict"><a href="#六、Python-中的-set-和-dict" class="headerlink" title="六、Python 中的 set 和 dict"></a><strong>六、Python 中的 set 和 dict</strong></h2><h3 id="1-dict-中的常用方法"><a href="#1-dict-中的常用方法" class="headerlink" title="1.dict 中的常用方法"></a><strong>1.dict 中的常用方法</strong></h3><h4 id="1-clear-方法："><a href="#1-clear-方法：" class="headerlink" title="(1)clear 方法："></a><strong>(1)clear 方法：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = {&quot;K0rz3n&quot;:{&quot;hello&quot;:&quot;world&quot;},
     &quot;KKKK&quot;:{&quot;hello&quot;:&quot;K0rz3n&quot;},
     &quot;xxxxx&quot;:{&quot;xxx&quot;:&quot;sssss&quot;}}

a.clear()
print a 
</code></pre><p><strong>结果：</strong></p>
<pre><code>{}
</code></pre><h4 id="2-copy-方法"><a href="#2-copy-方法" class="headerlink" title="(2)copy() 方法"></a><strong>(2)copy() 方法</strong></h4><blockquote>
<p><strong>注意：</strong></p>
<p>这个拷贝是浅拷贝，也就是说不能循环嵌套拷贝</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<pre><code>a = {&quot;K0rz3n&quot;:{&quot;hello&quot;:&quot;world&quot;},
     &quot;KKKK&quot;:{&quot;hello&quot;:&quot;K0rz3n&quot;},
     &quot;xxxxx&quot;:{&quot;xxx&quot;:&quot;sssss&quot;}}

new_dict = a.copy()
new_dict[&quot;K0rz3n&quot;][&quot;hello&quot;] = &quot;K0rz3n&quot;
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;K0rz3n&apos;: {&apos;hello&apos;: &apos;K0rz3n&apos;}, &apos;KKKK&apos;: {&apos;hello&apos;: &apos;K0rz3n&apos;}, &apos;xxxxx&apos;: {&apos;xxx&apos;: &apos;sssss&apos;}}
</code></pre><p>我们发现我们修改了拷贝值以后原始值也发生了变化，这其实就是浅拷贝导致的问题，浅拷贝遇到循环嵌套的数据时只能拷贝一层，另外的层都是一个指向，也就是指向原始的位置，因此修改了拷贝以后原始值也发生了变化</p>
<p><strong>解决：</strong></p>
<p>使用python 的一个 copy 的库</p>
<p><strong>示例代码</strong>：</p>
<pre><code>import copy
a = {&quot;K0rz3n&quot;:{&quot;hello&quot;:&quot;world&quot;},
     &quot;KKKK&quot;:{&quot;hello&quot;:&quot;K0rz3n&quot;},
     &quot;xxxxx&quot;:{&quot;xxx&quot;:&quot;sssss&quot;}}

new_dict = copy.deepcopy(a)
new_dict[&quot;K0rz3n&quot;][&quot;hello&quot;] = &quot;K0rz3n&quot;
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;K0rz3n&apos;: {&apos;hello&apos;: &apos;world&apos;}, &apos;KKKK&apos;: {&apos;hello&apos;: &apos;K0rz3n&apos;}, &apos;xxxxx&apos;: {&apos;xxx&apos;: &apos;sssss&apos;}}
</code></pre><h4 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="(3)fromkeys 方法"></a><strong>(3)fromkeys 方法</strong></h4><p>将可迭代的对象转化成为一个dict</p>
<p><strong>示例代码：</strong></p>
<pre><code>new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,{&quot;hhh&quot;})
print new_dict
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;K0rz3n&apos;: set([&apos;hhh&apos;]), &apos;world&apos;: set([&apos;hhh&apos;]), &apos;hello&apos;: set([&apos;hhh&apos;])}
</code></pre><h4 id="4-get-方法"><a href="#4-get-方法" class="headerlink" title="(4)get 方法"></a><strong>(4)get 方法</strong></h4><p>为了防止出现 keyerror 的错误</p>
<p><strong>示例代码：</strong></p>
<pre><code>new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,{&quot;hhh&quot;})

value = new_dict.get(&quot;hh&quot;,{})
print value
</code></pre><p><strong>结果：</strong></p>
<pre><code>{}
</code></pre><h4 id="5-items-方法"><a href="#5-items-方法" class="headerlink" title="(5)items 方法"></a><strong>(5)items 方法</strong></h4><p>Items 方法可以实现元祖的拆包</p>
<p><strong>示例代码：</strong></p>
<pre><code>new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,{&quot;hhh&quot;})

for key,value in new_dict.items():
    print key,value
</code></pre><p><strong>结果：</strong></p>
<pre><code>K0rz3n set([&apos;hhh&apos;])
world set([&apos;hhh&apos;])
hello set([&apos;hhh&apos;])
</code></pre><h4 id="6-setdefault-方法"><a href="#6-setdefault-方法" class="headerlink" title="(6)setdefault 方法"></a><strong>(6)setdefault 方法</strong></h4><p>除了试下 get 一样的操作以外，还会将这个值设置进映射</p>
<p><strong>示例代码：</strong></p>
<pre><code>new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,{&quot;hhh&quot;})

new_dict.setdefault(&quot;hh&quot;,&quot;xxx&quot;)
print new_dict
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;K0rz3n&apos;: set([&apos;hhh&apos;]), &apos;world&apos;: set([&apos;hhh&apos;]), &apos;hh&apos;: &apos;xxx&apos;, &apos;hello&apos;: set([&apos;hhh&apos;])}
</code></pre><h4 id="7-update-方法"><a href="#7-update-方法" class="headerlink" title="(7)update 方法"></a><strong>(7)update 方法</strong></h4><p>更新dict </p>
<p><strong>示例代码：</strong></p>
<pre><code>new_list = [&quot;K0rz3n&quot;,&quot;hello&quot;,&quot;world&quot;]
new_dict = dict.fromkeys(new_list,{&quot;hhh&quot;})

new_dict.update(update=&quot;hahah&quot;)
new_dict.update({&quot;upupup&quot;:&quot;xixixi&quot;})
print new_dict
</code></pre><p><strong>结果：</strong></p>
<pre><code>{&apos;K0rz3n&apos;: set([&apos;hhh&apos;]), &apos;world&apos;: set([&apos;hhh&apos;]), &apos;upupup&apos;: &apos;xixixi&apos;, &apos;hello&apos;: set([&apos;hhh&apos;]), &apos;update&apos;: &apos;hahah&apos;}
</code></pre><h3 id="2-set-和-frozeset"><a href="#2-set-和-frozeset" class="headerlink" title="2.set 和 frozeset"></a><strong>2.set 和 frozeset</strong></h3><p>set 是集合，是无序的，不重复的，frozenset 是不可变集合</p>
<p>set 中放置的是一个可迭代对象</p>
<h4 id="1-无序"><a href="#1-无序" class="headerlink" title="(1)无序"></a><strong>(1)无序</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = set(&apos;abcdefs&apos;)
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>set([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;f&apos;, &apos;s&apos;])
</code></pre><p>可见显示的顺序和我们传入的顺序是不一样的，也就是说是无序的</p>
<h4 id="（2）不重复"><a href="#（2）不重复" class="headerlink" title="（2）不重复"></a><strong>（2）不重复</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = set(&apos;abcdefssss&apos;)
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>set([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;f&apos;, &apos;s&apos;])
</code></pre><h4 id="（3）frozenset-是不可变的"><a href="#（3）frozenset-是不可变的" class="headerlink" title="（3）frozenset 是不可变的"></a><strong>（3）frozenset 是不可变的</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = set(&apos;abcdefssss&apos;)
a.add(&quot;x&quot;)
print a

b = frozenset(&apos;abcdefssss&apos;)
b.add(&quot;x&quot;)

print b
</code></pre><p><strong>结果：</strong></p>
<pre><code>set([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;f&apos;, &apos;s&apos;, &apos;x&apos;])
AttributeError: &apos;frozenset&apos; object has no attribute &apos;add&apos;
</code></pre><p><strong>（4）set 能使用update 更新</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>a = set(&apos;abcdefssss&apos;)
a.add(&quot;x&quot;)
b = set(&quot;xxx&quot;)
a.update(b)
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>set([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;f&apos;, &apos;s&apos;, &apos;x&apos;])
</code></pre><p><strong>（5）set 使用difference 求差集</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>a = set(&apos;abcdefssss&apos;)
a.add(&quot;x&quot;)
b = set(&quot;abcde&quot;)
new_set = a.difference(b)
print new_set
</code></pre><p><strong>结果：</strong></p>
<p>set([‘x’, ‘s’, ‘f’])</p>
<p>还有一种方式就是直接使用 - 号，其实底层都是使用魔法函数实现的，当然还有 | &amp; </p>
<p><strong>示例代码：</strong></p>
<pre><code>a = set(&apos;abcdefssss&apos;)
a.add(&quot;x&quot;)
b = set(&quot;abcde&quot;)
new_set = a.difference(b)
another_set = a-b
print new_set
print another_set
</code></pre><p><strong>结果：</strong></p>
<pre><code>set([&apos;x&apos;, &apos;s&apos;, &apos;f&apos;])
set([&apos;x&apos;, &apos;s&apos;, &apos;f&apos;])
</code></pre><h3 id="2-dict-背后的实现原理"><a href="#2-dict-背后的实现原理" class="headerlink" title="2.dict 背后的实现原理"></a><strong>2.dict 背后的实现原理</strong></h3><p>dict 背后都是通过hash 实现的，背后是一个数组，连续的内存空间，通过键值的hash到数组中寻找，因此速度非常的块。</p>
<p><strong>因此：</strong></p>
<ol>
<li>dict 的 key 和 set 的值都必须是可hash 的</li>
<li>dict 的内存花销大，但是查询速度快，很多自定义的对象或者是python 内部的对象都是用dict 包装的</li>
<li>dict 的存储顺序和存入的顺序有关</li>
<li>添加新的元素可能会改变已有数据的顺序（因为，在数组空间不足以后可能会新开辟一个新的数组，在元素进行转移的时候可能会改变存储顺序）</li>
</ol>
<h2 id="六、对象引用、可变性和垃圾回收"><a href="#六、对象引用、可变性和垃圾回收" class="headerlink" title="六、对象引用、可变性和垃圾回收"></a><strong>六、对象引用、可变性和垃圾回收</strong></h2><h3 id="1-Python-中的变量是什么？"><a href="#1-Python-中的变量是什么？" class="headerlink" title="1.Python 中的变量是什么？"></a><strong>1.Python 中的变量是什么？</strong></h3><p>Python 的变量和 Java 中的变量是不一样的，Java 中的变量是有大小的（因为有类型），声明一个变量就会在内存中开辟一定大小的空间，存放不同类型的数据，但是Python 不一样，Python 中的变量是一个指针，大小都是一样的</p>
<p><strong>示例代码：</strong></p>
<pre><code>a = [1,2,3,4]
b = a
b.append(5)
print a 
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 2, 3, 4, 5]
</code></pre><p>我们看到，我们修改b 实际上把a 也修改了，本质上是指向了同一个内存空间</p>
<h3 id="2-Python-中的-和-is"><a href="#2-Python-中的-和-is" class="headerlink" title="2.Python 中的 == 和 is"></a><strong>2.Python 中的 == 和 is</strong></h3><h4 id="（1）is-比较的是两个的-id"><a href="#（1）is-比较的是两个的-id" class="headerlink" title="（1）is 比较的是两个的 id"></a><strong>（1）is 比较的是两个的 id</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = [1,2,3,4]
b = a
print id(a),id(b)
print a is b
</code></pre><p><strong>结果：</strong></p>
<pre><code>50435592 50435592
True
</code></pre><p>但是有一个奇怪的情况</p>
<p><strong>示例代码：</strong></p>
<pre><code>a = [1,2,3]
b = [1,2,3]

print a is b

a = 1
b = 1

print a is b
</code></pre><p><strong>结果：</strong></p>
<pre><code>False
True
</code></pre><p><strong>解释：</strong></p>
<p>其实python 在对于小整数、小字符串的情况下不会另外新建内存空间</p>
<h4 id="（2）-比较的是值"><a href="#（2）-比较的是值" class="headerlink" title="（2）== 比较的是值"></a><strong>（2）== 比较的是值</strong></h4><p><strong>示例代码：</strong></p>
<pre><code>a = [1,2,3]
b = [1,2,3]

print a == b

a = 1
b = 1

print a == b
</code></pre><p><strong>结果：</strong></p>
<pre><code>True
True
</code></pre><h3 id="3-del-和垃圾回收"><a href="#3-del-和垃圾回收" class="headerlink" title="3.del 和垃圾回收"></a><strong>3.del 和垃圾回收</strong></h3><p>Python 中的垃圾回收机制使用的是引用计数的方式</p>
<p>del 并不能直接释放内存，只有在引用计数为0的时候才会释放</p>
<p><strong>示例代码：</strong></p>
<pre><code>a = object()
b = a

del  a
print b
print a
</code></pre><p><strong>结果：</strong></p>
<pre><code>&lt;object object at 0x00000000030F90C0&gt;
NameError: name &apos;a&apos; is not defined
</code></pre><h2 id="七、元类编程"><a href="#七、元类编程" class="headerlink" title="七、元类编程"></a><strong>七、元类编程</strong></h2><h3 id="1-property-动态属性"><a href="#1-property-动态属性" class="headerlink" title="1.property 动态属性"></a><strong>1.property 动态属性</strong></h3><p>使用 @property 装饰器将取函数的模式改变成取属性的模式</p>
<p>先看一下原始的使用调用函数的方法：</p>
<p><strong>示例代码：</strong></p>
<pre><code>from  datetime import date,datetime
class User():
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    def get_age(self):
        return datetime.now().year - self.birthday.year

if __name__ == &apos;__main__&apos;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age()
</code></pre><p><strong>结果：</strong></p>
<pre><code>19
</code></pre><p><strong>我们如果想用调用类的属性的方式访问呢？</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>from  datetime import date,datetime
class User():
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    @property
    def get_age(self):
        return datetime.now().year - self.birthday.year

if __name__ == &apos;__main__&apos;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age
</code></pre><p><strong>结果：</strong></p>
<pre><code>19
</code></pre><h3 id="2-getattr-和-getattribute"><a href="#2-getattr-和-getattribute" class="headerlink" title="2.getattr 和 getattribute"></a><strong>2.<strong>getattr</strong> 和 <strong>getattribute</strong></strong></h3><h4 id="1-getattr"><a href="#1-getattr" class="headerlink" title="(1)__getattr__"></a><strong>(1)<code>__getattr__</code></strong></h4><p>这个魔法方法会在找不到属性的时候调用</p>
<p><strong>示例代码：</strong></p>
<pre><code>from  datetime import date,datetime
class User():
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    def __getattr__(self, item):
        return &quot;can not find the attr&quot;

if __name__ == &apos;__main__&apos;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age
</code></pre><p><strong>结果：</strong></p>
<pre><code>can not find the attr
</code></pre><h4 id="2-getattribute"><a href="#2-getattribute" class="headerlink" title="(2)__getattribute__"></a><strong>(2)<code>__getattribute__</code></strong></h4><p>这个魔法函数在属性调用的时候会第一个调用，不管属性存不存在，可以把他看成是属性调用的入口，因为地位比较重要因此不建议重写</p>
<p><strong>示例代码:</strong></p>
<pre><code>from  datetime import date,datetime
class User(object):
    def __init__(self,name,birthday):
        self.name = name
        self.birthday = birthday

    def __getattr__(self, item):
        return &quot;can not find the attr&quot;

    def __getattribute__(self, item):
        return &quot;hello&quot;

if __name__ == &apos;__main__&apos;:
    user = User(&quot;K0rz3n&quot;,date(year = 1999,month = 11,day = 12))
    print user.get_age
</code></pre><p><strong>结果：</strong></p>
<pre><code>hello
</code></pre><h3 id="3-属性描述符和属性的查找过程"><a href="#3-属性描述符和属性的查找过程" class="headerlink" title="3.属性描述符和属性的查找过程"></a><strong>3.属性描述符和属性的查找过程</strong></h3><h4 id="（1）属性描述符："><a href="#（1）属性描述符：" class="headerlink" title="（1）属性描述符："></a><strong>（1）属性描述符</strong>：</h4><p>开发过程中可能会遇到一个问题：们想对用户传进来的数据类型进行控制，但是由于我们需要控制的数据过多，我们不能每一个都写同样的代码，于是这就涉及到了属性描述符，实际上属性描述符也只是实现了几个魔法方法而已（<code>__get__</code> 、<code>__set__</code> 、<code>__delete__</code>）</p>
<p>下面我们就自己实现一个属性描述符</p>
<p><strong>示例代码:</strong></p>
<pre><code>import numbers
class IntField(object):
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        if not isinstance(value,numbers.Integral):
            raise ValueError(&quot;not int&quot;)
        self.value = value
    def __delete__(self, instance):
        pass

class User(object):
    age = IntField()

if __name__ == &apos;__main__&apos;:
    user = User()
    user.age = &quot;xxx&quot;
    print user.age
</code></pre><p><strong>结果：</strong></p>
<pre><code>ValueError: not int
</code></pre><p>当然我们能多加几个条件：</p>
<p><strong>示例代码：</strong></p>
<pre><code>import numbers
class IntField(object):
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        if not isinstance(value,numbers.Integral):
            raise ValueError(&quot;not int&quot;)
        if value &lt; 0:
            raise ValueError(&quot;not &gt; 0&quot;)
        self.value = value
    def __delete__(self, instance):
        pass

class User(object):
    age = IntField()

if __name__ == &apos;__main__&apos;:
    user = User()
    user.age = -9
    print user.age
</code></pre><p><strong>结果：</strong></p>
<pre><code>ValueError: not &gt; 0
</code></pre><h3 id="4-new-和-init-的区别"><a href="#4-new-和-init-的区别" class="headerlink" title="4.__new__ 和 __init__ 的区别"></a><strong>4.<code>__new__</code> 和 <code>__init__</code> 的区别</strong></h3><p><code>__new__</code> 可以自定义类的生成过程,而<code>__init__</code>控制的是类生成的对象，因此 new 的调用是在 init 的之前</p>
<p><strong>示例代码:</strong></p>
<pre><code>class User(object):
    def __new__(cls, *args, **kwargs):
        print &quot;new&quot;
    def __init__(self,name):
        self.name = name
        print &quot;init&quot;
if __name__ == &apos;__main__&apos;:
    user = User(&quot;K0rz3n&quot;)
</code></pre><p><strong>结果：</strong></p>
<pre><code>new
</code></pre><p>这里其实还发现一个问题，就是如果 new 方法不返回对象，Init 就永远得不到调用</p>
<p><strong>示例代码：</strong></p>
<pre><code>class User(object):
    def __new__(cls, *args, **kwargs):
        print &quot;new&quot;
        return super(User,cls).__new__(cls)
    def __init__(self,name):
        self.name = name
        print &quot;init&quot;

if __name__ == &apos;__main__&apos;:
    user = User(&quot;K0rz3n&quot;)
</code></pre><p><strong>结果：</strong></p>
<pre><code>new
init
</code></pre><h3 id="5-自定义元类"><a href="#5-自定义元类" class="headerlink" title="5.自定义元类"></a><strong>5.自定义元类</strong></h3><p><strong>概念：</strong></p>
<p>元类是什么呢？元类就是创建类的类，比如我们之前讲的 type() 就是一个元类，再比如我们在Py3 中创建类的时候在括号中写 metaclass =  这个就是在指明这个类的元类，MetaClass 也是一个类，他是继承于type的，我们自定义 MetaClass 来控制类对象生成的过程</p>
<p>通过 type() 动态的创建一个类,<strong>语法是 type(类名，继承关系，属性或者方法)</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>User = type(&quot;User&quot;,(),{})

user = User()

print type(user)
</code></pre><p><strong>结果：</strong></p>
<pre><code>&lt;class &apos;__main__.User&apos;&gt;
</code></pre><p><strong>我们现在来创建一个带有属性的类</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>User = type(&quot;User&quot;,(),{&quot;name&quot;:&quot;K0rz3n&quot;})
user = User()
print user.name
</code></pre><p><strong>结果:</strong></p>
<pre><code>K0rz3n
</code></pre><p><strong>我们现在来创建一个带有方法的类</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>def get_age(self):
    print &quot;get_age&quot;

if __name__ == &apos;__main__&apos;:
    User = type(&quot;User&quot;,(),{&quot;name&quot;:&quot;K0rz3n&quot;,&quot;get_age&quot;:get_age})
    user = User()
    print user.name
    print user.get_age()
</code></pre><p><strong>结果：</strong></p>
<pre><code>K0rz3n
get_age
None
</code></pre><p><strong>我们可以创建一个继承基类的类</strong></p>
<p><strong>示例代码：</strong></p>
<pre><code>class BaseClass(object):
    def answer(self):
        return &quot;i am baseclass&quot;


if __name__ == &apos;__main__&apos;:
    User = type(&quot;User&quot;,(BaseClass,),{&quot;name&quot;:&quot;K0rz3n&quot;,&quot;get_age&quot;:get_age})
    user = User()
    print user.answer()
</code></pre><p><strong>结果:</strong></p>
<pre><code>i am baseclass
</code></pre><h2 id="八、Python-的迭代器和生成器"><a href="#八、Python-的迭代器和生成器" class="headerlink" title="八、Python 的迭代器和生成器"></a><strong>八、Python 的迭代器和生成器</strong></h2><h3 id="1-Python-中的迭代协议："><a href="#1-Python-中的迭代协议：" class="headerlink" title="1.Python 中的迭代协议："></a><strong>1.Python 中的迭代协议：</strong></h3><p><strong>什么是迭代器？</strong></p>
<p>迭代器是访问集合类元素的一种方式，我们能实现for循环其实背后就是迭代器,迭代器在Python 中叫做 Iterator ,背后实现的是 <code>__next__</code> 和 <code>__iter__</code> 方法</p>
<p><strong>示例代码：</strong></p>
<pre><code>from collections import Iterable,Iterator
a = [1,2,3,4,5]

print isinstance(a,Iterable)
print isinstance(a,Iterator)
</code></pre><p><strong>结果：</strong></p>
<pre><code>True
False
</code></pre><p><strong>解释：</strong></p>
<p>可以看到 a 是一个列表，他是可迭代的，但是他并不是一个迭代器</p>
<h3 id="2-Python-中迭代器和可迭代对象的区别："><a href="#2-Python-中迭代器和可迭代对象的区别：" class="headerlink" title="2.Python 中迭代器和可迭代对象的区别："></a><strong>2.Python 中迭代器和可迭代对象的区别：</strong></h3><h4 id="1-回顾一下之前的代码："><a href="#1-回顾一下之前的代码：" class="headerlink" title="1.回顾一下之前的代码："></a><strong>1.回顾一下之前的代码：</strong></h4><pre><code>class Company(object):
    def __init__(self,employ_list):
        self.employ = employ_list
    def __getitem__(self, item):
        return self.employ[item]

if __name__ == &apos;__main__&apos;:
    company = Company([&quot;tom&quot;,&quot;bob&quot;,&quot;angel&quot;])
    for item in company:
        print item
</code></pre><p><strong>为什么这个能执行循环呢？</strong></p>
<p>实际上，我们在调用循环的时候会自动调用，iter() 这个方法，这个方法回去寻找实例化这个对象的类中有没有<code>__iter__</code> 这个方法,如果没有他会再退一步寻找<code>__getitem__</code> 这个魔法方法，然后完成调用.</p>
<h4 id="2-我们来自己实现一个迭代器："><a href="#2-我们来自己实现一个迭代器：" class="headerlink" title="2.我们来自己实现一个迭代器："></a><strong>2.我们来自己实现一个迭代器：</strong></h4><p><strong>示例代码：</strong></p>
<pre><code># coding=utf-8
from collections import Iterator

class MyIterator(Iterator):
    def __init__(self, employ_list):
        self.iter = employ_list
        self.index = 0

    def next(self):  # 真正返回迭代之的逻辑
        try:
            word = self.iter[self.index]
        except IndexError:
            raise StopIteration
        self.index += 1
        return word


class Company(object):
    def __init__(self, employ_list):
        self.employ = employ_list

    def __getitem__(self, item):
        return self.employ[item]

    def __iter__(self):
        return MyIterator(self.employ)


if __name__ == &apos;__main__&apos;:
    company = Company([&quot;tom&quot;, &quot;bob&quot;, &quot;angel&quot;])
    for i in company:
        print i
</code></pre><p><strong>结果：</strong></p>
<pre><code>tom
bob
angel
</code></pre><h3 id="3-Python-中的生成器函数："><a href="#3-Python-中的生成器函数：" class="headerlink" title="3.Python 中的生成器函数："></a><strong>3.Python 中的生成器函数：</strong></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a><strong>1.概念：</strong></h4><blockquote>
<p><strong>什么是生成器函数？</strong></p>
<p>只要函数中有 yield 关键字，这个函数就是生成器函数</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<pre><code>def gen_test():
    yield 1

def test():
    return 2

if __name__ == &apos;__main__&apos;:
    gen = gen_test()
    res = test()

    print gen
    print res
</code></pre><p><strong>结果：</strong></p>
<pre><code>&lt;generator object gen_test at 0x00000000032457E0&gt;
2
</code></pre><p><strong>解释：</strong></p>
<p>我们看到，看似同样是定义一个函数，但是第一个实际上是一个生成器，生成器返回的是一个生成器对象，第二个返回的只是一个干巴巴的数据。</p>
<p><strong>那么我们怎么利用这个生成器的返回值呢？</strong></p>
<p>实际上他底层实现也是一个生成器，既然是生成器我们就能通过循环的方式调用</p>
<p><strong>示例代码：</strong></p>
<pre><code>def gen_test():
    yield 1

def test():
    return 2

if __name__ == &apos;__main__&apos;:
    gen = gen_test()
    res = test()

    for i in gen:
        print i
</code></pre><p><strong>结果：</strong></p>
<pre><code>1
</code></pre><h4 id="2-看一下生成器的优势："><a href="#2-看一下生成器的优势：" class="headerlink" title="2.看一下生成器的优势："></a><strong>2.看一下生成器的优势：</strong></h4><p>原始的生成 斐波那契数列的方法：</p>
<p><strong>示例代码：</strong></p>
<pre><code>def fib(index):
    fib_list = []
    n,a,b = 0,0,1
    while n &lt; index:
        fib_list.append(b)
        a,b = b,a+b
        n += 1
    return fib_list

fib_list = fib(10)
print fib_list
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre><p>但是这种方法在数字非常大的时候就非常的占用内存空间，他会先把结果放在数组中再返回给我们，于是我们尝试使用生成器</p>
<p><strong>示例代码：</strong></p>
<pre><code>def fib(index):
    n,a,b = 0,0,1
    while n &lt; index:
        yield b
        a,b = b,a+b
        n += 1

if __name__ == &apos;__main__&apos;:
    fib_list = []
    for i in fib(10):
        fib_list.append(i)
    print fib_list
</code></pre><p><strong>结果：</strong></p>
<pre><code>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre><p>生成器方式就能实现在循环中不断生成，避免了一下子生成，（当然我这个代码为了方便大家看最后还是放在了列表中）</p>
<h3 id="4-Python-是怎么实现生成器的："><a href="#4-Python-是怎么实现生成器的：" class="headerlink" title="4.Python 是怎么实现生成器的："></a><strong>4.Python 是怎么实现生成器的：</strong></h3><h4 id="1-先来讲讲Python-是怎么实现函数调用的"><a href="#1-先来讲讲Python-是怎么实现函数调用的" class="headerlink" title="1.先来讲讲Python 是怎么实现函数调用的"></a><strong>1.先来讲讲Python 是怎么实现函数调用的</strong></h4><p><strong>实例函数：</strong></p>
<pre><code>def foo():
    pass
def bar():
    pass
</code></pre><p>首先 python 有一个C语言写的Python的解释器，Python 的所有的代码都是运行在这个解释器之上的，然后我们开始调用foo 函数，一调用函数解释器就会在堆上分配一个栈帧，然后我们在这个栈帧上执行这个函数，然后发现他调用了一个子函数，又会在堆上分配一个新的栈帧，所有的栈帧都分配在堆上，这也就是说，栈帧能脱离于调用者存在</p>
<p>而生成器实际上就是对我们的栈帧进行的一次封装。保存了当前运行的状态，也就是说，我们能够使用其实现迭代</p>
<h4 id="接下来介绍函数装饰器的使用"><a href="#接下来介绍函数装饰器的使用" class="headerlink" title="接下来介绍函数装饰器的使用"></a>接下来介绍函数装饰器的使用</h4><p>这一部分我打算单独拿出来做一篇文章，请关注我的文章列表的 <strong>Python实用编程技巧(装饰器篇)</strong></p>
</div><div class="tags"><a href="/tags/编程-Python-进阶-备忘/">编程 Python 进阶 备忘</a></div><div class="post-nav"><a class="pre" href="/2018/10/05/PHP 基础教程（漫谈）/">PHP 基础教程（漫谈）</a><a class="next" href="/2018/10/04/Python 实用编程技巧（装饰器篇）/">Python 实用编程技巧（装饰器篇）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.k0rz3n.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/APT/">APT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kerberos/">Kerberos</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/learning/">learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web安全/">web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/wireshark/">wireshark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘/">备忘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘-笔记/">备忘 笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习思考/">学习思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具使用/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发/">开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/渗透测试/">渗透测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞分析/">漏洞分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞研究/">漏洞研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/">论文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/渗透测试-windows-后门/" style="font-size: 15px;">渗透测试 windows 后门</a> <a href="/tags/APT/" style="font-size: 15px;">APT</a> <a href="/tags/备忘-反向代理-配置/" style="font-size: 15px;">备忘 反向代理 配置</a> <a href="/tags/开发-Github-备忘/" style="font-size: 15px;">开发 Github 备忘</a> <a href="/tags/Linux-渗透测试-备忘/" style="font-size: 15px;">Linux 渗透测试 备忘</a> <a href="/tags/配置-备忘/" style="font-size: 15px;">配置 备忘</a> <a href="/tags/编程-Python-进阶-备忘/" style="font-size: 15px;">编程 Python 进阶 备忘</a> <a href="/tags/网络安全-Python语法/" style="font-size: 15px;">网络安全 Python语法</a> <a href="/tags/gcc-备忘-笔记/" style="font-size: 15px;">gcc 备忘 笔记</a> <a href="/tags/learning/" style="font-size: 15px;">learning</a> <a href="/tags/Windows-FTP搭建-备忘/" style="font-size: 15px;">Windows FTP搭建 备忘</a> <a href="/tags/CTF-Tools/" style="font-size: 15px;">CTF Tools</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/学习发现/" style="font-size: 15px;">学习发现</a> <a href="/tags/kali/" style="font-size: 15px;">kali</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/php语法/" style="font-size: 15px;">php语法</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/渗透测试/" style="font-size: 15px;">渗透测试</a> <a href="/tags/wireshark/" style="font-size: 15px;">wireshark</a> <a href="/tags/Linux-备忘/" style="font-size: 15px;">Linux 备忘</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/备忘-shell-Linux/" style="font-size: 15px;">备忘 shell Linux</a> <a href="/tags/备忘/" style="font-size: 15px;">备忘</a> <a href="/tags/工具使用/" style="font-size: 15px;">工具使用</a> <a href="/tags/网络安全-渗透测试-内网代理/" style="font-size: 15px;">网络安全 渗透测试 内网代理</a> <a href="/tags/渗透测试-局域网扫描/" style="font-size: 15px;">渗透测试 局域网扫描</a> <a href="/tags/备忘-dcoker-getshell-CTF/" style="font-size: 15px;">备忘 dcoker getshell CTF</a> <a href="/tags/渗透测试-技巧/" style="font-size: 15px;">渗透测试 技巧</a> <a href="/tags/二进制-栈溢出/" style="font-size: 15px;">二进制 栈溢出</a> <a href="/tags/网络安全-Google-Hacking-信息收集-渗透测试/" style="font-size: 15px;">网络安全 Google Hacking 信息收集 渗透测试</a> <a href="/tags/J2EE-基础/" style="font-size: 15px;">J2EE 基础</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/web安全-漏洞-CTF/" style="font-size: 15px;">web安全  漏洞  CTF</a> <a href="/tags/PHP-备忘-笔记/" style="font-size: 15px;">PHP 备忘 笔记</a> <a href="/tags/工具-渗透测试/" style="font-size: 15px;">工具 渗透测试</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/web安全-CTF-渗透测试-PHP/" style="font-size: 15px;">web安全 CTF 渗透测试 PHP</a> <a href="/tags/CSP/" style="font-size: 15px;">CSP</a> <a href="/tags/Java-备忘-笔记/" style="font-size: 15px;">Java 备忘 笔记</a> <a href="/tags/域渗透/" style="font-size: 15px;">域渗透</a> <a href="/tags/网络安全-渗透测试-sqlmap/" style="font-size: 15px;">网络安全 渗透测试 sqlmap</a> <a href="/tags/静态检测/" style="font-size: 15px;">静态检测</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/Fuzz-XSS/" style="font-size: 15px;">Fuzz XSS</a> <a href="/tags/笔记-协议分析/" style="font-size: 15px;">笔记 协议分析</a> <a href="/tags/Redis-备忘/" style="font-size: 15px;">Redis 备忘</a> <a href="/tags/web安全-漏洞分析/" style="font-size: 15px;">web安全 漏洞分析</a> <a href="/tags/漏洞研究/" style="font-size: 15px;">漏洞研究</a> <a href="/tags/网络安全-钓鱼-恶意代码分析-漏洞分析/" style="font-size: 15px;">网络安全 钓鱼 恶意代码分析 漏洞分析</a> <a href="/tags/密码学-网络协议/" style="font-size: 15px;">密码学 网络协议</a> <a href="/tags/JSONP/" style="font-size: 15px;">JSONP</a> <a href="/tags/编程-C-类库/" style="font-size: 15px;">编程 C++ 类库</a> <a href="/tags/java-备忘/" style="font-size: 15px;">java 备忘</a> <a href="/tags/web安全-CTF/" style="font-size: 15px;">web安全 CTF</a> <a href="/tags/CTF-writeup/" style="font-size: 15px;">CTF writeup</a> <a href="/tags/web安全-MySQL-渗透测试/" style="font-size: 15px;">web安全 MySQL 渗透测试</a> <a href="/tags/编程-PHP-基础/" style="font-size: 15px;">编程 PHP 基础</a> <a href="/tags/网络安全-沙盒逃逸-Python/" style="font-size: 15px;">网络安全 沙盒逃逸 Python</a> <a href="/tags/SQL-语法/" style="font-size: 15px;">SQL 语法</a> <a href="/tags/Fuzz/" style="font-size: 15px;">Fuzz</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/tags/编程-PHP-进阶/" style="font-size: 15px;">编程 PHP 进阶</a> <a href="/tags/符号执行/" style="font-size: 15px;">符号执行</a> <a href="/tags/XSS/" style="font-size: 15px;">XSS</a> <a href="/tags/编程-JAVA-基础/" style="font-size: 15px;">编程 JAVA 基础</a> <a href="/tags/Windows-批处理-备忘/" style="font-size: 15px;">Windows 批处理 备忘</a> <a href="/tags/污点分析/" style="font-size: 15px;">污点分析</a> <a href="/tags/PHP-静态检测/" style="font-size: 15px;">PHP 静态检测</a> <a href="/tags/SQL-注入/" style="font-size: 15px;">SQL 注入</a> <a href="/tags/流量分析/" style="font-size: 15px;">流量分析</a> <a href="/tags/编程-C-基础/" style="font-size: 15px;">编程 C++ 基础</a> <a href="/tags/编程-进阶/" style="font-size: 15px;">编程 进阶</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/27/reGeorg 工作流程分析(以 php 为例)/">reGeorg 工作流程分析(以 php 为例)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/CCProxy6.2 栈溢出分析/">CCProxy6.2 栈溢出分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/10/python3 爬虫知识梳理(框架篇)/">Python3 爬虫知识梳理(框架篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/python3 爬虫知识梳理(实战篇)/">Python3 爬虫知识梳理(实战篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/03/Python3 爬虫知识梳理(基础篇)/">Python3 爬虫知识梳理(基础篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/29/New Page ,New Future/">New Page,New Future</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/JAVA 泛型、动态代理技术要点梳理/">JAVA 泛型、动态代理技术要点梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/TCTF 2019 线上赛 web 题 writeup/">TCTF 2019 线上赛 web 题 writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/2018 APT (Advanced Persistent Threat)攻击大事件/">2018 APT (Advanced Persistent Threat)攻击大事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/21/APT(高级持续威胁) 概念以及趋势概述/">APT(高级持续威胁) 概念以及趋势概述</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://math1as.com/" title="math1as" target="_blank">math1as</a><ul></ul><a href="https://www.zsxsoft.com/" title="zsx" target="_blank">zsx</a><ul></ul><a href="https://www.lorexxar.cn/" title="Lorexxar" target="_blank">Lorexxar</a><ul></ul><a href="https://chybeta.github.io/" title="Chybeta" target="_blank">Chybeta</a><ul></ul><a href="http://www.cnblogs.com/iamstudy/" title="L3m0n" target="_blank">L3m0n</a><ul></ul><a href="http://www.pupiles.com" title="pupiles" target="_blank">pupiles</a><ul></ul><a href="http://f1sh.site/" title="f1sh" target="_blank">f1sh</a><ul></ul><a href="https://www.leavesongs.com/" title="phithon" target="_blank">phithon</a><ul></ul><a href="http://sh3ll.me/" title="Chu" target="_blank">Chu</a><ul></ul><a href="https://www.virzz.com/" title="Virink" target="_blank">Virink</a><ul></ul><a href="http://blog.cal1.cn/" title="超威蓝猫" target="_blank">超威蓝猫</a><ul></ul><a href="https://ricterz.me" title="RicterZ" target="_blank">RicterZ</a><ul></ul><a href="https://cyto.top/" title="Cytosine" target="_blank">Cytosine</a><ul></ul><a href="http://foreversong.cn/" title="ADog" target="_blank">ADog</a><ul></ul><a href="http://www.ckj123.com/" title="cjk123" target="_blank">cjk123</a><ul></ul><a href="http://arch0n.sumblog.cn" title="August" target="_blank">August</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">K0rz3n's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>