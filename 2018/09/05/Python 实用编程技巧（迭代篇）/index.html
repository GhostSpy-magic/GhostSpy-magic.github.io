<!DOCTYPE html>
<html lang="zh-CN">










<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content>
    <meta name="author" content="John Doe">
    <meta name="keywords" content>
    <title>Python 实用编程技巧（迭代篇） ~ Hexo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/css/mdb.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_vr10bjtg3us.css">
    
        <link rel="stylesheet" href="/css/Prettify/tomorrow-night-eighties.min.css">
    
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/"><strong>Hexo</strong></a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2" style='background: url("https://i.imgur.com/oADD1Ip.jpg")no-repeat center center;background-size: cover;'>
    <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
        <div class="container text-center white-text wow fadeInUp">
            <p class="h2">Python 实用编程技巧（迭代篇）</p>
            <br>
            
            <p>Wednesday, September 5th 2018, 2:11 pm</p>
            
        </div>
        </div>
    </div>
    </div>
  </header>

  <main>
  
  <div class="container-fluid">
    <div class="row">
        <div class="col-md-8 offset-md-2 ">
            <div class="post-content py-5 z-depth-3 main">
                <h2 id="1-如何实现可迭代对象和迭代器对象"><a href="#1-如何实现可迭代对象和迭代器对象" class="headerlink" title="1.如何实现可迭代对象和迭代器对象"></a><strong>1.如何实现可迭代对象和迭代器对象</strong></h2><p>如果想从网络上抓取数据存入字典，然后再对字典进行迭代显示，由于网络I/O操作的时间相对较长，这样就会造成用户的长时间等待，我们希望能一次抓取就显示一次，于是迭代器对象出现了。<br><a id="more"></a><br>在 for 循环的时候 in 后面跟的是一个可迭代对象，在循环的过程中自动调用 iter(） 将可迭代对象传入其中，返回一个迭代器对象</p>
<p><strong>比如我们常见的列表和字符串都是可迭代对象，为什么呢？</strong></p>
<p>这涉及到了 Python 的魔法方法的问题，python一切皆对象，而魔法方法就是好像是python对象的一个插件，有什么样子的魔法方法，python 对象就会在关键时刻显示某种特性（仿佛科幻小说中主人公体内某种隐藏的力量被激活）。迭代对象有一个魔法方法 <code>__iter__</code>,如果没有这个方法，那么python 还会退而求其次，去寻找<code>__getitem__</code> 这个代表他是一个序列的方法，也是可迭代的。</p>
<p>迭代器对象只有一个方法就是 next()，每调用一次就会迭代一次，知道全部迭代完毕抛出异常，这其实也是for 循环的工作机制（这同时也说明了一个问题：迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素）。</p>
<pre><code>l = [1,2,3,4,5,6]

t = iter(l)
print t.next()
print t.next()
print t.next()
</code></pre><p><strong>结果：</strong></p>
<pre><code>1
2
3
</code></pre><p><strong>实例：</strong></p>
<ol>
<li>实现一个迭代器对象，有next 方法每次返回一个值</li>
<li>实现一个可迭代对象  <code>__iter__</code> 方法返回上面的那个迭代器对象</li>
</ol>
<p>实际上就是创建一个可迭代对象的类，实例化以后成为一个可迭代对象，然后一旦在循环中调用这个可迭代对象就能自动调用<code>__init__</code>,然后实例化迭代器对象的类，这个类的实例会在迭代中不断调用next方法。</p>
<p>代码如下：</p>
<pre><code>import requests

from collections import Iterable,Iterator

class WeatherIterator(Iterator):
    def __init__(self,cities):
        self.cities = cities
        self.index = 0

    def getWeather(self,city):
        r = requests.get(u&quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot; + city)
        data = r.json()[&apos;data&apos;][&apos;forecast&apos;][0]
        return &apos;%s: %s , %s&apos; % (city, data[&apos;low&apos;], data[&apos;high&apos;])

    def next(self):
        if self.index == len(self.cities):
            raise StopIteration
        city = self.cities[self.index]
        self.index += 1
        return self.getWeather(city)


class WeatherIterable(Iterable):
    def __init__(self,cities):
        self.cities = cities

    def __iter__(self):
        return WeatherIterator(self.cities)


for x in WeatherIterable([u&quot;北京&quot;,u&quot;上海&quot;,u&quot;广州&quot;,u&quot;长春&quot;]):
    print x
</code></pre><h2 id="2-如何使用生成器函数实现可迭代对象"><a href="#2-如何使用生成器函数实现可迭代对象" class="headerlink" title="2.如何使用生成器函数实现可迭代对象"></a><strong>2.如何使用生成器函数实现可迭代对象</strong></h2><p>那么什么是生成器？</p>
<p>生成器对象其实是一种特殊的可迭代对象，他自己调用<code>__iter__</code>方法返回的是他自身，因此他既是一个可迭代对象，也是一个迭代器对象，而且它不需要再像上面的类一样写<code>__iter__()</code>和<code>__next__()</code>方法了，只需要一个yiled关键字（当然你可以重写<code>__iter__</code>来实现自己的功能）。 (说人话就是这个生成器的对象在每一次迭代的时候都会被yiled卡住并返回，下一次再迭代就会接着上次执行，是不是很优雅？)</p>
<p>举一个简单的生成器的例子：</p>
<pre><code>def f():
    print &apos;first&apos;
    yield 1

    print &apos;second&apos;
    yield 2

    print &apos;third&apos;
    yield 3

g = f()
for x in g:
    print x
</code></pre><p> <strong>结果：</strong>   </p>
<pre><code>first
1
second
2
third
3
</code></pre><p><strong>实例：</strong></p>
<p>找出指定范围内的所有素数</p>
<pre><code>class PrimeNumbers:
    def __init__(self,start,end):
        self.start = start
        self.end = end

    def isPrimeNum(self,k):
        if k&lt;2:
            return False
        for x in xrange(2,k):
            if k % x == 0:
                return False
        return True

    def __iter__(self):
        for k in xrange(self.start,self.end+1):
            if self.isPrimeNum(k):
                yield k

for x in PrimeNumbers(1,100):
    print x
</code></pre><h2 id="3-如何进行反向迭代以及如何实现反向迭代"><a href="#3-如何进行反向迭代以及如何实现反向迭代" class="headerlink" title="3.如何进行反向迭代以及如何实现反向迭代"></a><strong>3.如何进行反向迭代以及如何实现反向迭代</strong></h2><h3 id="列表的反向迭代"><a href="#列表的反向迭代" class="headerlink" title="列表的反向迭代"></a><strong>列表的反向迭代</strong></h3><p>（1）使用列表的反转操作</p>
<pre><code>l = [1,2,3,4,5]
x = l.reverse()
</code></pre><p>但这种情况会改变原列表</p>
<p>（2）使用切片且步进为-1</p>
<pre><code>l = [1,2,3,4,5]
x = l[::-1]
</code></pre><p>但这样会生成一个新的列表</p>
<p>（3）列表反向迭代器</p>
<pre><code>l = [1,2,3,4,5]
for x in reversed(l):
    print x
</code></pre><p>这种情况和iter()刚好是相反的，在迭代的时候会自动调用 <code>__reversed__</code>对象。</p>
<p><strong>实例：</strong></p>
<p>写一个浮点数生成器，既可以正向迭代又可以反向迭代</p>
<pre><code>class FloatRange:
    def __init__(self,start,end,step):
        self.start = start
        self.end  = end
        self.step = step

    def __iter__(self):
        t = self.start
        while t &lt;= self.end:
            yield t
            t +=self.step
    def __reversed__(self):
        t = self.end
        while t &gt;= self.start:
            yield t
            t -= self.step

for x in FloatRange(1.0,3.0,0.5):
    print x

print &quot;===============cut-off rule=====================&quot;

for x in reversed(FloatRange(1.0,3.0,0.5)):
    print x
</code></pre><h2 id="4-如何对迭代器做切片操作"><a href="#4-如何对迭代器做切片操作" class="headerlink" title="4.如何对迭代器做切片操作"></a><strong>4.如何对迭代器做切片操作</strong></h2><p>我们知道文本文件本身也是一个可迭代对象，每次迭代返回的是文本文件的一行，那么我们思考一个问题，我们能不能像对列表切片一样对文本文件切片得到一个迭代器（生成器），这样比如我们想迭代的是100行带300行之间的内容就能直接迭代了。</p>
<h3 id="简单回顾文件迭代"><a href="#简单回顾文件迭代" class="headerlink" title="简单回顾文件迭代"></a><strong>简单回顾文件迭代</strong></h3><p>由于文件对象没有<code>__getitem__</code>这个方法，于是没有和列表一样的迭代操作，那我们就可以先把文件的内容放到一个列表里面，然后再进行切片，如下：</p>
<pre><code>f = open(&apos;./LICENCE&apos;)
lines = f.readlines()
for x in lines[100:300]:
    print x
</code></pre><p>但是这样有一个问题，readlines 会把文件的所有内容都先加载到内存里面，但是如果文件非常大，比如有几个G大小，那么就会遇到内存不足的问题，于是我们只能选择使用</p>
<pre><code>for line in f:
    print line,
</code></pre><p><strong>注意：</strong>如果文件指针此时已经在文件的末尾，你是循环不出内容的，我们还需要将使用 f.seek(0)，将文件指针还原回去</p>
<p>因此我们迫切的需要将文件变成一个迭代器。</p>
<pre><code>from itertools import islice
f = open(&apos;./LICENCE&apos;)
for i in islice(f,100,300):
    print i
</code></pre><p>如果是想得到前100行的迭代器</p>
<pre><code>from itertools import islice
f = open(&apos;./LICENCE&apos;)
for i in islice(f,100):
    print i
</code></pre><p>如果想得到从100行开始到最后的迭代器</p>
<pre><code>from itertools import islice
f = open(&apos;./LICENCE&apos;)
for i in islice(f,100,None):
    print i
</code></pre><p>注意： islice() 虽然看上去是从100开始的，但是前99行实际上也迭代了，因此下一次使用的时候注意还原。</p>
<h2 id="5-如何在一个for-语句中迭代多个可迭代对象"><a href="#5-如何在一个for-语句中迭代多个可迭代对象" class="headerlink" title="5.如何在一个for 语句中迭代多个可迭代对象"></a><strong>5.如何在一个for 语句中迭代多个可迭代对象</strong></h2><h3 id="1-并行迭代"><a href="#1-并行迭代" class="headerlink" title="1.并行迭代"></a><strong>1.并行迭代</strong></h3><p>比如 语数外三科成绩分别存储在3个列表中，我们现在需要同时迭代三个列表取出三个成绩，并计算总成绩</p>
<p>最简单的我们可以使用索引的方式</p>
<pre><code>from random import randint
chinese = [randint(60,100) for i in xrange(40)]
math = [randint(60,100) for i in xrange(40)]
english = [randint(60,100) for i in xrange(40)]

for x in xrange(len(math)):
    print chinese[x]+math[x]+english[x]
</code></pre><p>但是这个方法有局限性，因为并不是所有的可迭代对象都支持索引的方法访问其中的元素</p>
<p><strong>高阶推荐：zip()</strong></p>
<p>zip() 中能传入多个<strong>可迭代对象</strong>并将其逐项合并成一个元组列表，然后我们就能使用元组拆包的方式进行迭代</p>
<pre><code>from random import randint
chinese = [randint(60,100) for i in xrange(40)]
math = [randint(60,100) for i in xrange(40)]
english = [randint(60,100) for i in xrange(40)]

grade = []
for c,m,e in zip(chinese,math,english):
    grade.append(c+m+e)
print grade
</code></pre><h3 id="2-串行"><a href="#2-串行" class="headerlink" title="2.串行"></a><strong>2.串行</strong></h3><p>比如每个班的英语成绩放在一个列表中，现在想迭代全年级的英语成绩，找出分数高于90分的人数</p>
<p>使用 itertools 的 chain 可以多个可迭代对象进行串行连接</p>
<pre><code>from random import randint
from itertools import chain
e1 = [randint(60,100) for i in xrange(40)]
e2 = [randint(60,100) for i in xrange(40)]
e3 = [randint(60,100) for i in xrange(40)]
e4 = [randint(60,100) for i in xrange(40)]

count = 0

for x in chain(e1,e2,e3,e4):
    if x &gt; 90:
        count += 1
</code></pre>
                <hr>
                <div>
                    <p>
                         
                        <span class="badge badge-light">#&nbsp;编程 Python 进阶 备忘</span>
                        &nbsp;
                        
                    </p>
                </div>
                <br>
                
                    <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
                
            </div>
        </div>
        <div class="d-none d-md-block col-md-2">
            
  <div id="toc" class="py-5">
    <p class="h6"><i class="iconfont icon-toc" style="vertical-align:middle"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>        
</div>

<br><br><br>

<!-- Comments -->
<div class="comments" id="comments">
 
</div>
  
  </main>

<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank"><b>HEXO</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank"> <b>Material-T</b></a>
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/jquery-3.3.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.7.4/js/mdb.min.js"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    
    <script src="/js/post.js"></script>
    
      <script src="/js/plugins/prettify.js"></script>
      <script>
          $(document).ready(function(){
              $('pre').addClass('prettyprint linenums');
              prettyPrint();
          })
      </script>
    
  
</body>
</html>